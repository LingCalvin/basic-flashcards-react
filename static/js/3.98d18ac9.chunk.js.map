{"version":3,"sources":["../../src/utils.ts","../../src/actions.ts","../../src/constants.ts","../../src/streams.ts","../../src/pipe.ts","../../src/transformers.ts","../../src/system.ts","../../src/index.ts","../../src/comparators.tsx","../../src/domIOSystem.ts","../../src/propsReadySystem.ts","../../src/stateFlagsSystem.ts","../../src/scrollSeekSystem.ts","../../src/AATree.ts","../../src/utils/binaryArraySearch.ts","../../src/sizeSystem.ts","../../src/scrollToIndexSystem.ts","../../src/sizeRangeSystem.ts","../../src/windowScrollerSystem.ts","../../src/gridSystem.ts","../../src/hooks/useSize.ts","../../src/hooks/useWindowViewportRect.ts","../../src/hooks/useIsomorphicLayoutEffect.ts","../../src/hooks/useScrollTop.ts","../../src/initialTopMostItemIndexSystem.ts","../../src/followOutputSystem.ts","../../src/groupedListSystem.ts","../../src/listStateSystem.ts","../../src/utils/simpleMemoize.ts","../../src/initialItemCountSystem.ts","../../src/topItemCountSystem.ts","../../src/totalListHeightSystem.ts","../../src/upwardScrollFixSystem.ts","../../src/initialScrollTopSystem.ts","../../src/alignToBottomSystem.ts","../../src/listSystem.ts","../../src/utils/positionStickyCssValue.ts","../../src/List.tsx","../../src/hooks/useChangedChildSizes.ts","../../src/Grid.tsx","../../src/components.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js","../node_modules/@material-ui/icons/esm/Delete.js","../node_modules/@material-ui/icons/esm/ArrowUpward.js","../node_modules/@material-ui/icons/esm/ArrowDownward.js"],"names":["compose","a","b","thrush","arg","proc","curry2to1","arg1","arg2","curry1to0","prop","property","object","tap","tup","args","call","always","value","joinProc","procs","noop","subscribe","emitter","subscription","publish","publisher","reset","getValue","depot","connect","handleNext","unsub","stream","subscriptions","indexOf","Error","statefulStream","initial","innerSubject","action","streamFromEmitter","statefulStreamFromEmitter","combineOperators","operators","pipe","source","project","defaultComparator","previous","next","distinctUntilChanged","comparator","done","current","filter","predicate","map","mapTo","scan","scanner","skip","times","throttleTime","interval","currentValue","timeout","setTimeout","withLatestFrom","sources","values","Array","called","allCalled","Math","bit","concat","duc","combineLatest","emitters","system","constructor","dependencies","singleton","id","Symbol","useIsomorphicLayoutEffect","document","systemToComponent","systemSpec","Root","requiredPropNames","Object","optionalPropNames","methodNames","eventNames","Context","createContext","requiredPropName","props","optionalPropName","handlers","cleanup","currentSubscription","eventHandler","Component","forwardRef","children","propsWithChildren","useState","singletons","_init","init","applyPropsToSystem","buildEventHandlers","eventName","useImperativeHandle","ref","acc","buildMethods","createElement","result","index","idx","len","keys","obj","omit","usePublisher","useCallback","React","useEmitterValue","useContext","setValue","useEmitter","callback","tupleComparator","prev","rangeComparator","startIndex","endIndex","UP","domIOSystem","u","scrollTop","deviation","smoothScrollTargetReached","statefulScrollTop","viewportHeight","headerHeight","footerHeight","scrollTo","scrollBy","scrollingInProgress","scrollDirection","direction","prevScrollTop","propsReadySystem","propsReady","didMount","ready","INITIAL_BOTTOM_STATE","atBottom","notAtBottomBecause","state","offsetBottom","totalHeight","stateFlagsSystem","isAtBottom","isAtTop","atBottomStateChange","atTopStateChange","listStateListener","isScrolling","clearTimeout","top","atBottomState","bottom","scrollSeekSystem","scrollVelocity","isSeeking","rangeChanged","scrollSeekConfiguration","speed","config","range","enter","exit","change","scrollSeekRangeChanged","NIL_NODE","lvl","newAANode","k","v","l","r","empty","node","newTree","remove","key","last","adjust","clone","deleteLast","findMaxKeyValue","field","Infinity","insert","split","skew","walkWithin","start","end","push","walk","isSingle","rl","rlvl","rangesWithin","arrayToRanges","items","parser","length","i","nextIndex","nextValue","findIndexOfClosestSmallerOrEqual","floor","match","join","findClosestSmallerOrEqual","rangeIncludes","refRange","size","indexComparator","itemIndex","offsetComparator","offset","itemOffset","offsetPointParser","point","sizeStateReducer","ranges","groupIndices","sizeTree","offsetTree","newSizeTree","syncStart","groupSize","itemSize","reduce","tree","groupIndex","min","overlappingRanges","some","firstPassDone","shouldInsert","rangeStart","rangeEnd","rangeValue","prevIndex","prevSize","prevAOffset","startAIndex","arrayBinarySearch","kv","slice","aOffset","groupOffsetTree","offsetOf","lastIndex","lastOffset","lastSize","originalIndexFromItemIndex","sizes","hasGroups","groupOffset","sizeSystem","sizeRanges","totalCount","unshiftWith","firstItemIndex","fixedItemSize","defaultItemSize","data","indexes","trackItemSizes","listRefresh","newSizes","changed","diff","val","beforeUnshiftWith","SUPPORTS_SCROLL_TO_OPTIONS","documentElement","style","normalizeIndexLocation","location","align","behavior","scrollToIndexSystem","scrollToIndex","topListHeight","unsubscribeNextListRefresh","cleartTimeoutRef","unsubscribeListRefresh","normalLocation","max","round","retry","listChanged","getOverscan","overscan","main","reverse","sizeRangeSystem","listBoundary","visibleRange","listTop","listBottom","windowScrollerSystem","windowViewportRect","windowScrollTop","windowScrollTo","useWindowScroll","offsetTop","INITIAL_GRID_STATE","itemHeight","itemWidth","PROBE_GRID_STATE","ceil","hackFloor","buildItems","from","_","gridSystem","stateFlags","scrollSeek","initialItemCount","gridState","viewportDimensions","height","width","itemDimensions","startOffset","endOffset","item","viewport","viewportWidth","perRow","gridLayout","endReached","startReached","itemTop","totalListHeight","viewportInfo","visibleWidth","visibleHeight","useSizeWithElRef","enabled","useRef","observer","ResizeObserver","entries","element","target","offsetParent","callbackRef","elRef","observe","unobserve","useSize","useWindowViewportRectRef","calculateInfo","rect","getBoundingClientRect","window","innerHeight","pageYOffset","windowEH","useEffect","addEventListener","removeEventListener","useLayoutEffect","useScrollTop","scrollTopCallback","scrollerElement","scrollerRefCallback","scrollerRef","scrollTopTarget","timeoutRef","handler","ev","el","scrollHeight","offsetHeight","localRef","passive","scrollByCallback","scrollToCallback","isSmooth","initialTopMostItemIndexSystem","scrolledToInitialItem","initialTopMostItemIndex","normalizeFollowOutput","follow","followOutputSystem","followOutput","scrollToBottom","followOutputBehavior","shouldFollow","behaviorFromFollowOutput","refreshed","cancel","groupCountsToIndicesAndCount","counts","groupCount","groupedListSystem","groupCounts","topItemsIndexes","groupIndicesAndCount","EMPTY_LIST_STATE","topItems","transposeItems","originalIndex","transposedItems","groupRanges","currentRange","currentGroupIndex","shift","type","buildListState","lastItem","func","listStateSystem","rangeTopListHeight","itemsRendered","listState","sizesValue","rangeStartIndex","rangeEndIndex","minStartIndex","offsetPointRanges","endValue","maxIndex","t","initialItemCountSystem","count","includedGroupsCount","adjustedCount","topItemCountSystem","topItemCount","totalListHeightSystem","totalListHeightChanged","upwardScrollFixSystem","deviationOffset","prevItems","newDev","prevFirstItemIndex","prevItem","find","pItem","initialScrollTopSystem","initialScrollTop","alignToBottomSystem","alignToBottom","paddingTopAddition","featureGroup1System","listSystem","domIO","flags","featureGroup1","fixedItemHeight","defaultItemHeight","positionStickyCssValue","position","identity","listComponentPropsSystem","itemContent","groupContent","components","computeItemKey","headerFooterTag","distinctProp","propName","defaultValue","FooterComponent","HeaderComponent","TopItemListComponent","ListComponent","ItemComponent","GroupComponent","ScrollerComponent","EmptyPlaceholder","ScrollSeekPlaceholder","addDeprecatedAlias","message","alias","console","warn","combinedSystem","propsSystem","deprecatedProps","group","scrollingStateChange","adjustForPrependedItems","maxHeightCacheSize","footer","header","HeaderContainer","FooterContainer","ItemContainer","ScrollContainer","GroupContainer","ListContainer","emptyComponent","deprecateComponentProp","componentName","comp","placeholder","DefaultScrollSeekPlaceholder","GROUP_STYLE","zIndex","Items","showTopList","results","child","dataset","parseInt","knownSize","lastResult","containerStyle","boxSizing","paddingTop","paddingBottom","marginTop","data-index","data-known-size","data-item-index","data-item-group-index","scrollerStyle","outline","overflowY","WebkitOverflowScrolling","viewportStyle","topItemListStyle","Header","Footer","buildScroller","tabIndex","buildWindowScroller","Viewport","viewportRef","WindowViewport","TopItemListContainer","TopItemList","required","optional","methods","events","TheViewport","WindowScroller","Scroller","List","gridComponentPropsSystem","itemClassName","listClassName","GridItems","listRef","firstItem","firstChild","offsetWidth","className","Grid","Virtuoso","_objectWithoutProperties","excluded","sourceKeys","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","MapShim","Map","getIndex","arr","entry","class_1","this","__entries__","defineProperty","get","enumerable","configurable","set","delete","splice","has","clear","forEach","ctx","_i","_a","isBrowser","global$1","global","self","Function","requestAnimationFrame$1","requestAnimationFrame","bind","Date","now","transitionKeys","mutationObserverSupported","MutationObserver","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","refresh","delay","leadingCall","trailingCall","lastCallTime","resolvePending","proxy","timeoutCallback","timeStamp","throttle","addObserver","connect_","removeObserver","observers","disconnect_","updateObservers_","activeObservers","gatherActive","hasActive","broadcastActive","attributes","childList","characterData","subtree","disconnect","_b","propertyName","getInstance","instance_","defineConfigurable","writable","getWindowOf","ownerDocument","defaultView","emptyRect","createRectInit","toFloat","parseFloat","getBordersSize","styles","positions","arguments","getHTMLElementContentRect","clientWidth","clientHeight","getComputedStyle","paddings","positions_1","getPaddings","horizPad","left","right","vertPad","isDocumentElement","vertScrollbar","horizScrollbar","abs","isSVGGraphicsElement","SVGGraphicsElement","SVGElement","getBBox","getContentRect","bbox","getSVGContentRect","x","y","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","isActive","broadcastRect","ResizeObserverEntry","rectInit","contentRect","Constr","DOMRectReadOnly","create","createReadOnlyRect","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","TypeError","callback_","controller_","callbackCtx_","Element","observations","clearActive","_this","observation","WeakMap","method","apply","createSvgIcon","d"],"mappings":"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","file":"static/js/3.98d18ac9.chunk.js","sourcesContent":["/**\n * Utils includes\n * - a handful of functional utilities inspired by or taken from the [Ramda library](https://ramdajs.com/);\n * - TypeScript crutches - the [[tup]] function.\n *\n * Use these for your convenience - they are here so that urx is zero-dependency package.\n *\n * @packageDocumentation\n */\n\n/** @internal */\nexport interface Proc {\n  (): any\n}\n\n/**\n * Performs left to right composition of two functions.\n */\nexport function compose<I, A, R>(a: (arg: A) => R, b: (arg: I) => A): (arg: I) => R {\n  return (arg: I) => a(b(arg))\n}\n\n/**\n * Takes a value and applies a function to it.\n */\nexport function thrush<I, K>(arg: I, proc: (arg: I) => K) {\n  return proc(arg)\n}\n\n/**\n * Takes a 2 argument function and partially applies the first argument.\n */\nexport function curry2to1<T, K, R>(proc: (arg1: T, arg2: K) => R, arg1: T): (arg2: K) => R {\n  return arg2 => proc(arg1, arg2)\n}\n\n/**\n * Takes a 1 argument function and returns a function which when called, executes it with the provided argument.\n */\nexport function curry1to0<T, R>(proc: (arg: T) => R, arg: T): () => R {\n  return () => proc(arg)\n}\n\n/**\n * Returns a function which extracts the property from from the passed object.\n */\nexport function prop(property: string) {\n  return (object: any) => object[property]\n}\n\n/**\n * Calls callback with the first argument, and returns it.\n */\nexport function tap<T>(arg: T, proc: (arg: T) => any): T {\n  proc(arg)\n  return arg\n}\n\n/**\n *  Utility function to help typescript figure out that what we pass is a tuple and not a generic array.\n *  Taken from (this StackOverflow tread)[https://stackoverflow.com/questions/49729550/implicitly-create-a-tuple-in-typescript/52445008#52445008]\n */\nexport function tup<T extends Array<any>>(...args: T): T {\n  return args\n}\n\n/**\n * Calls the passed function.\n */\nexport function call(proc: Proc) {\n  proc()\n}\n\n/**\n * returns a function which when called always returns the passed value\n */\nexport function always<T>(value: T) {\n  return () => value\n}\n\n/**\n * returns a function which calls all passed functions in the passed order.\n * joinProc does not pass arguments or collect return values.\n */\nexport function joinProc(...procs: Proc[]) {\n  return () => {\n    procs.map(call)\n  }\n}\n\nexport function noop() {}\n","/**\n * urx Actions operate on streams - `publish` publishes data in a stream, and `subscribe` attaches a subscription to a stream.\n * @packageDocumentation\n */\nimport { PUBLISH, RESET, SUBSCRIBE, VALUE } from './constants'\nimport { curry2to1 } from './utils'\n\n/**\n * A Publisher is the **input end** of a Stream. The [[publish]] action publishes values in publishers.\n * @typeParam T the type of values to be published.\n */\nexport interface Publisher<T> {\n  /** @internal */\n  (action: PUBLISH, value: T): void\n}\n\n/**\n * An Emitter is the **output end** of a Stream. The [[subscribe]] action binds {@link Subscription | subscriptions} to emitters.\n * @typeParam T the type of values that will be emitted.\n */\nexport interface Emitter<T> {\n  /** @internal */\n  (action: SUBSCRIBE, subscription: Subscription<T>): Unsubscribe\n  /** @internal */\n  (action: RESET): void\n}\n\n/**\n * Subscriptions are bound to Emitters with the [[subscribe]] action, and get called with the new values.\n * @typeParam T the Emitter value type.\n */\nexport interface Subscription<T> {\n  (value: T): any\n}\n\n/**\n * Subscribe-like actions return unsubscribe handles of the Unsubscribe type, which, when called, unbind the subscription.\n */\nexport interface Unsubscribe {\n  (): void\n}\n\n/**\n * Streams present both the input and the output ends of a stream.\n * A single stream instance can be both subscribed to and published in.\n */\nexport interface Stream<T> extends Publisher<T>, Emitter<T> {\n  /** @internal */\n  (action: SUBSCRIBE | PUBLISH | RESET): any // fix for bug with pipe + connect\n}\n\n/**\n * Just like {@link Stream | streams}, stateful streams present both input and output ends of a stream.\n * A single stream instance can be both subscribed to and published in.\n * Stateful Streams can also act like depots, preserving the last passed value and immediately publishing it to new subscriptions.\n * [[getValue]] can be used to extract value from stateful streams.\n */\nexport interface StatefulStream<T> extends Publisher<T>, Emitter<T> {\n  /** @internal */\n  (action: SUBSCRIBE | PUBLISH | RESET | VALUE): any // fix for bug with pipe + connect\n  // StatefulStream should extend rather then duplicate the signature, but this somehow causes a bug in TS\n}\n\n/**\n * Subscribes the specified [[Subscription]] to the updates from the Emitter.\n * The emitter calls the subscription with the new data each time new data is published into it.\n *\n * ```ts\n * const foo = stream<number>();\n * subscribe(foo, (value) => console.log(value));\n * ```\n *\n * @returns an [[Unsubscribe]] handle  - calling it will unbind the subscription from the emitter.\n *```ts\n * const foo = stream<number>();\n * const unsub = subscribe(foo, (value) => console.log(value));\n * unsub();\n *```\n */\nexport function subscribe<T>(emitter: Emitter<T>, subscription: Subscription<T>): Unsubscribe {\n  return emitter(SUBSCRIBE, subscription)\n}\n\n/**\n * Publishes the value into the passed [[Publisher]].\n *\n * ```ts\n * const foo = stream<number>();\n * publish(foo, 42);\n * ```\n */\nexport function publish<T>(publisher: Publisher<T>, value: T) {\n  publisher(PUBLISH, value)\n}\n\n/**\n * Clears all subscriptions from the [[Emitter]].\n * ```ts\n * const foo = stream<number>();\n * subscribe(foo, (value) => console.log(value));\n * reset(foo);\n * publish(foo, 42);\n * ```\n */\nexport function reset(emitter: Emitter<any>) {\n  emitter(RESET)\n}\n\n/**\n * Extracts the current value from a stateful stream. Use it only as an escape hatch, as it violates the concept of reactive programming.\n * ```ts\n * const foo = statefulStream(42);\n * console.log(getValue(foo));\n * ```\n */\nexport function getValue<T>(depot: StatefulStream<T>): T {\n  return depot(VALUE)\n}\n\n/**\n * Connects two streams - any value emitted from the emitter will be published in the publisher.\n * ```ts\n * const foo = stream<number>();\n * const bar = stream<number>();\n * subscribe(bar, (value) => console.log(`Bar emitted ${value}`));\n *\n * connect(foo, bar);\n * publish(foo);\n * ```\n * @returns an [[Unsubscribe]] handle which will disconnect the two streams.\n */\nexport function connect<T>(emitter: Emitter<T>, publisher: Publisher<T>) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH))\n}\n\n/**\n * Executes the passed subscription at most once, for the next emit from the emitter.\n * ```ts\n * const foo = stream<number>()\n * handleNext(foo, value => console.log(value)) // called once, with 42\n * publish(foo, 42)\n * publish(foo, 43)\n * ```\n * @returns an [[Unsubscribe]] handle to unbind the subscription if necessary.\n */\nexport function handleNext<T>(emitter: Emitter<T>, subscription: Subscription<T>) {\n  const unsub = emitter(SUBSCRIBE, value => {\n    unsub()\n    subscription(value)\n  })\n  return unsub\n}\n","export const PUBLISH = 0 as const\nexport type PUBLISH = typeof PUBLISH\n\nexport const SUBSCRIBE = 1 as const\nexport type SUBSCRIBE = typeof SUBSCRIBE\n\nexport const RESET = 2 as const\nexport type RESET = typeof RESET\n\nexport const VALUE = 4 as const\nexport type VALUE = typeof VALUE\n","/**\n * Streams are the basic building blocks of a reactive system. Think of them as the system permanent \"data tubes\".\n *\n * A stream acts as both an [[Emitter]] and [[Publisher]]. Each stream can have multiple {@link Subscription | Subscriptions}.\n *\n * urx streams are either **stateless** or **stateful**.\n * Stateless streams emit data to existing subscriptions when published, without keeping track of it.\n * Stateful streams remember the last published value and immediately publish it to new subscriptions.\n *\n * ```ts\n * import { stream, statefulStream, publish, subscribe } from \"@virtuoso.dev/urx\";\n *\n * // foo is a stateless stream\n * const foo = stream<number>();\n *\n * publish(foo, 42);\n * // this subsription will not be called...\n * subscribe(foo, (value) => console.log(value));\n * // it will only catch published values after it\n * publish(foo, 43);\n *\n * // stateful streams always start with an initial value\n * const bar = statefulStream(42);\n *\n * // subscribing to a stateful stream\n * // immediately calls the subscription with the current value\n * subscribe(bar, (value) => console.log(value));\n *\n * // subsequent publishing works just like stateless streams\n * publish(bar, 43);\n * ```\n * @packageDocumentation\n */\n\nimport { Emitter, StatefulStream, Stream, Subscription, Unsubscribe, subscribe, connect } from './actions'\nimport { RESET, PUBLISH, SUBSCRIBE, VALUE } from './constants'\nimport { tap, noop } from './utils'\n\n/**\n * Constructs a new stateless stream.\n * ```ts\n * const foo = stream<number>();\n * ```\n * @typeParam T the type of values to publish in the stream.\n * @returns a [[Stream]]\n */\nexport function stream<T>(): Stream<T> {\n  const subscriptions = [] as Subscription<T>[]\n\n  return ((action: PUBLISH | SUBSCRIBE | RESET, arg: any) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length)\n        return\n      case SUBSCRIBE:\n        subscriptions.push(arg)\n        return () => {\n          const indexOf = subscriptions.indexOf(arg)\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1)\n          }\n        }\n      case PUBLISH:\n        subscriptions.slice().forEach(subscription => {\n          subscription(arg as T)\n        })\n        return\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  }) as Stream<T>\n}\n\n/**\n * Constructs a new stateful stream.\n * ```ts\n * const foo = statefulStream(42);\n * ```\n * @param initial the initial value in the stream.\n * @typeParam T the type of values to publish in the stream. If omitted, the function infers it from the initial value.\n * @returns a [[StatefulStream]]\n */\nexport function statefulStream<T>(initial: T): StatefulStream<T> {\n  let value: T = initial\n  const innerSubject = stream<T>()\n\n  return ((action: PUBLISH | SUBSCRIBE | RESET | VALUE, arg: any) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg as Subscription<T>\n        subscription(value)\n        break\n      case PUBLISH:\n        value = arg as T\n        break\n      case VALUE:\n        return value\n    }\n    return innerSubject(action as any, arg)\n  }) as StatefulStream<T>\n}\n\n/**\n * Event handlers are special emitters which can have **at most one active subscription**.\n * Subscribing to an event handler unsubscribes the previous subscription, if present.\n * ```ts\n * const foo = stream<number>();\n * const fooEvent = eventHandler(foo);\n *\n * // will be called once with 42\n * subscribe(fooEvent, (value) => console.log(`Sub 1 ${value}`));\n * publish(foo, 42);\n *\n * // unsubscribes sub 1\n * subscribe(fooEvent, (value) => console.log(`Sub 2 ${value}`));\n * publish(foo, 43);\n * ```\n * @param emitter the source emitter.\n * @returns the single-subscription emitter.\n */\nexport function eventHandler<T>(emitter: Emitter<T>) {\n  let unsub: Unsubscribe | undefined\n  let currentSubscription: any\n  let cleanup = () => unsub && unsub()\n\n  return function(action: SUBSCRIBE | RESET, subscription?: Subscription<T>) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return\n          }\n          cleanup()\n          currentSubscription = subscription\n          unsub = subscribe(emitter, subscription!)\n          return unsub\n        } else {\n          cleanup()\n          return noop\n        }\n      case RESET:\n        cleanup()\n        currentSubscription = null\n        return\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  } as Emitter<T>\n}\n\n/**\n * Creates and connects a \"junction\" stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\n *\n * ```ts\n * const foo = stream<number>();\n *\n * const fooX2 = pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`multiplying ${value}`);\n *     return value * 2;\n *   })\n * );\n *\n * subscribe(fooX2, (value) => console.log(value));\n * subscribe(fooX2, (value) => console.log(value));\n *\n * publish(foo, 42); // executes the map operator twice for each subscription.\n *\n * const sharedFooX2 = streamFromEmitter(pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`shared multiplying ${value}`);\n *     return value * 2;\n *   })\n * ));\n *\n * subscribe(sharedFooX2, (value) => console.log(value));\n * subscribe(sharedFooX2, (value) => console.log(value));\n *\n * publish(foo, 42);\n *```\n * @returns the resulting stream.\n */\nexport function streamFromEmitter<T>(emitter: Emitter<T>): Stream<T> {\n  return tap(stream<T>(), stream => connect(emitter, stream))\n}\n\n/**\n * Creates and connects a \"junction\" stateful stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\n *\n * ```ts\n * const foo = stream<number>();\n *\n * const fooX2 = pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`multiplying ${value}`);\n *     return value * 2;\n *   })\n * );\n *\n * subscribe(fooX2, (value) => console.log(value));\n * subscribe(fooX2, (value) => console.log(value));\n *\n * publish(foo, 42); // executes the map operator twice for each subscription.\n *\n * const sharedFooX2 = statefulStreamFromEmitter(pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`shared multiplying ${value}`);\n *     return value * 2;\n *   })\n * ), 42);\n *\n * subscribe(sharedFooX2, (value) => console.log(value));\n * subscribe(sharedFooX2, (value) => console.log(value));\n *\n * publish(foo, 42);\n *```\n * @param initial the initial value in the stream.\n * @returns the resulting stateful stream.\n */\nexport function statefulStreamFromEmitter<T>(emitter: Emitter<T>, initial: T): StatefulStream<T> {\n  return tap(statefulStream(initial), stream => connect(emitter, stream))\n}\n","/**\n *\n * Stream values can be transformed and controlled by {@link pipe | **piping**} through **operators**.\n * urx includes several operators like [[map]], [[filter]], [[scan]], and [[throttleTime]].\n * The [[withLatestFrom]] operator allows the combination of values from other streams.\n *\n * ```ts\n * const foo = stream<number>()\n *\n * // create an emitter that first adds 2 to the passed value, then multiplies it by * 2\n * const bar = pipe(foo, map(value => value + 2), map(value => value * 2))\n * subscribe(bar, value => console.log(value))\n * publish(foo, 2) // outputs 8\n * ```\n *\n * ### Implementing Custom Operators\n * To implement your own operators, implement the [[Operator]] interface.\n * @packageDocumentation\n */\nimport { compose, thrush } from './utils'\nimport { Emitter, subscribe, Subscription, reset } from './actions'\nimport { SUBSCRIBE, RESET } from './constants'\n\n/**\n * Operators can transform and control the flow of values.\n * [[pipe]] is used to transform one Emitter into another by stacking operators to its values.\n * To build your own operator that looks like the built-in ones,\n * create a function which returns an operator.\n * The following custom operator multiplies the passed value:\n *\n * ```ts\n * function multiplyBy(multiplier: number): Operator<number> {\n *  return done => value => done(value * multiplier)\n * }\n *\n * const foo = stream<number>()\n * const multipliedFoo = pipe(foo, multiplyBy(3))\n * subscribe(multipliedFoo, value => console.log(value))\n * publish(foo, 42)\n * ```\n */\nexport interface Operator<Input, Output = Input> {\n  (done: (value: Output) => void): (value: Input) => void\n}\n\n/** @internal */\ntype CombineOperatorsReturnType<I, O> = (subscriber: (value: O) => void) => (value: I) => void\n\n/** @internal */\nfunction combineOperators<I>(...operators: Operator<any, any>[]): CombineOperatorsReturnType<I, any> {\n  return (subscriber: (value: any) => void) => {\n    return operators.reduceRight(thrush, subscriber)\n  }\n}\n\n/** @internal */\ntype O<I, OP> = Operator<I, OP>\n\n/**\n * Creates a new emitter from the passed one by piping its values through one or more operators.\n * Operators can perform various actions like filter values, pull values from other emitters, or compute new values.\n *\n * ```ts\n * const foo = stream<number>()\n *\n * // create an emitter that first adds 2 to the passed value, then multiplies it by * 2\n * const bar = pipe(foo, map(value => value + 2), map(value => value * 2))\n * subscribe(bar, value => console.log(value))\n * publish(foo, 2) // outputs 8\n * ```\n * #### Sharing Subscription Calculations\n *\n * `pipe` acts as a proxy for the source emitter, and re-runs the operators for each subscription to the derived emitter.\n * Use [[streamFromEmitter]] or [[statefulStreamFromEmitter]] to avoid that.\n */\nexport function pipe<T>(s: Emitter<T>): Emitter<T> // prettier-ignore\nexport function pipe<T, O1>(s: Emitter<T>, o1: O<T, O1>): Emitter<O1> // prettier-ignore\nexport function pipe<T, O1, O2>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>]): Emitter<O2> // prettier-ignore\nexport function pipe<T, O1, O2, O3>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>]): Emitter<O3> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>]): Emitter<O4> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4, O5>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>]): Emitter<O5> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4, O5, O6>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>]): Emitter<O6> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4, O5, O6, O7>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>, O<O6, O7>]): Emitter<O7> // prettier-ignore\nexport function pipe<T>(source: Emitter<T>, ...operators: O<any, any>[]): Emitter<any> {\n  // prettier-ignore\n  const project = combineOperators(...operators)\n  return ((action: SUBSCRIBE | RESET, subscription: Subscription<any>) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription))\n      case RESET:\n        reset(source)\n        return\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  }) as Emitter<any>\n}\n\n/**\n * A function which determines if two values are equal.\n * Implement custom comparators when [[distinctUntilChanged]] needs to work on non-primitive objects.\n * @returns true if values should be considered equal.\n */\nexport interface Comparator<T> {\n  (previous: T, next: T): boolean\n}\n\n/**\n * The default [[Comparator]] for [[distinctUntilChanged]] and [[duc]].\n */\nexport function defaultComparator<T>(previous: T, next: T) {\n  return previous === next\n}\n\n/**\n * Filters out identical values. Pass an optional [[Comparator]] if you need to filter non-primitive values.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, distinctUntilChanged()),\n *  console.log\n * ) // will be called only once\n *\n * publish(foo, 42)\n * publish(foo, 42)\n * ```\n */\nexport function distinctUntilChanged<T>(comparator: Comparator<T> = defaultComparator): Operator<T> {\n  let current: T\n  return done => next => {\n    if (!comparator(current, next)) {\n      current = next\n      done(next)\n    }\n  }\n}\n\n/**\n * Filters out values for which the predicator does not return `true`-ish.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, filter(value => value % 2 === 0)),\n *  console.log\n * ) // will be called only with even values\n *\n * publish(foo, 2)\n * publish(foo, 3)\n * publish(foo, 4)\n * publish(foo, 5)\n * ```\n */\nexport function filter<T>(predicate: (value: T) => boolean): Operator<T> {\n  return done => value => {\n    predicate(value) && done(value)\n  }\n}\n\n/**\n * Maps values using the provided project function.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, map(value => value * 2)),\n *  console.log\n * ) // 4, 6\n *\n * publish(foo, 2)\n * publish(foo, 3)\n * ```\n */\nexport function map<T, K>(project: (value: T) => K): Operator<T, K> {\n  return done => compose(done, project)\n}\n\n/**\n * Maps values to the hard-coded value.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, mapTo(3)),\n *  console.log\n * ) // 3, 3\n *\n * publish(foo, 1)\n * publish(foo, 2)\n * ```\n */\nexport function mapTo<T>(value: T): Operator<any, T> {\n  return done => () => done(value)\n}\n\n/**\n * Works like Array#reduce.\n * Applies an accumulator function on the emitter, and outputs intermediate result. Starts with the initial value.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, scan((acc, value) => acc + value, 2),\n *  console.log\n * ) // 3, 5\n *\n * publish(foo, 1)\n * publish(foo, 2)\n * ```\n */\nexport function scan<T, K>(scanner: (current: T, value: K) => T, initial: T): Operator<K, T> {\n  return done => value => done((initial = scanner(initial, value)))\n}\n\n/**\n * Skips the specified amount of values from the emitter.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, skip(2)),\n *  console.log\n * ) // 3, 4\n *\n * publish(foo, 1) // skipped\n * publish(foo, 2) // skipped\n * publish(foo, 3)\n * publish(foo, 4)\n * ```\n */\nexport function skip<T>(times: number): Operator<T> {\n  return done => value => {\n    times > 0 ? times-- : done(value)\n  }\n}\n\n/**\n * Throttles flowing values at the provided interval in milliseconds.\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\n *\n * ```ts\n *  const foo = stream<number>()\n *  publish(foo, 1)\n *\n *  setTimeout(() => publish(foo, 2), 20)\n *  setTimeout(() => publish(foo, 3), 20)\n *\n *  subscribe(pipe(foo, throttleTime(50)), val => {\n *    console.log(value); // 3\n *  })\n * ```\n */\nexport function throttleTime<T>(interval: number): Operator<T> {\n  let currentValue: T | undefined\n  let timeout: any\n\n  return done => value => {\n    currentValue = value\n\n    if (timeout) {\n      return\n    }\n\n    timeout = setTimeout(() => {\n      timeout = undefined\n      done(currentValue!)\n    }, interval)\n  }\n}\n\n/**\n * Debounces flowing values at the provided interval in milliseconds.\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\n *\n * ```ts\n *  const foo = stream<number>()\n *  publish(foo, 1)\n *\n *  setTimeout(() => publish(foo, 2), 20)\n *  setTimeout(() => publish(foo, 3), 20)\n *\n *  subscribe(pipe(foo, debounceTime(50)), val => {\n *    console.log(value); // 3\n *  })\n * ```\n */\nexport function debounceTime<T>(interval: number): Operator<T> {\n  let currentValue: T | undefined\n  let timeout: any\n\n  return done => value => {\n    currentValue = value\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n\n    timeout = setTimeout(() => {\n      done(currentValue!)\n    }, interval)\n  }\n}\n\n/**\n * Combines the source Emitter with the latest values from the specified Emitters into an array. Outputs only when the source Emitter emits.\n * See [[combineLatest]] for a transformer that outputs when any of the emitters emit.\n *\n * ```ts\n *  const foo = stream<number>()\n *  const bar = stream<number>()\n *  subscribe(\n *    pipe(\n *      foo,\n *      withLatestFrom(bar)\n *    ),\n *    (([foo, bar]) => console.log({ foo, bar }))\n *  )\n *\n *  publish(foo, 1) // nothing happens, bar has not emitted yet\n *  publish(bar, 1) // still nothing\n *  publish(foo, 2) // logs { foo: 2, bar: 1 }\n *  publish(bar, 2)\n *  publish(foo, 3) // logs { foo: 3, bar: 2 }\n * ```\n */\nexport function withLatestFrom<T, R1>(...s: [Emitter<R1>]): Operator<T, [T, R1]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2>(...s: [Emitter<R1>, Emitter<R2>]): Operator<T, [T, R1, R2]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>]): Operator<T, [T, R1, R2, R3]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>]): Operator<T, [T, R1, R2, R3, R4]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4, R5>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>, Emitter<R5>]): Operator<T, [T, R1, R2, R3, R4, R5]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>, Emitter<R5>, Emitter<R6>]): Operator<T, [T, R1, R2, R3, R4, R5, R6]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6, R7>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>, Emitter<R5>, Emitter<R6>, Emitter<R7>]): Operator<T, [T, R1, R2, R3, R4, R5, R6, R7]> // prettier-ignore\nexport function withLatestFrom(...sources: Emitter<any>[]): Operator<any, any> {\n  const values = new Array(sources.length)\n  let called = 0\n  const allCalled = Math.pow(2, sources.length) - 1\n\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index)\n    subscribe(source, value => {\n      called = called | bit\n      values[index] = value\n    })\n  })\n\n  return done => value => {\n    if (called === allCalled) {\n      done([value].concat(values))\n    }\n  }\n}\n","/**\n * Transformers change and combine streams, similar to operators.\n * urx comes with two combinators - [[combineLatest]] and [[merge]], and one convenience filter - [[duc]].\n *\n * @packageDocumentation\n */\nimport { Emitter, publish, reset, subscribe, Subscription } from './actions'\nimport { RESET, SUBSCRIBE } from './constants'\nimport { Comparator, defaultComparator, distinctUntilChanged, pipe } from './pipe'\nimport { stream } from './streams'\nimport { joinProc } from './utils'\n\n/**\n * Merges one or more emitters from the same type into a new Emitter which emits values from any of the source emitters.\n * ```ts\n * const foo = stream<number>()\n * const bar = stream<number>()\n *\n * subscribe(merge(foo, bar), (value) => console.log(value)) // 42, 43\n *\n * publish(foo, 42)\n * publish(bar, 43)\n * ```\n */\nexport function merge<T>(...sources: Emitter<T>[]): Emitter<T> {\n  return function(action: SUBSCRIBE | RESET, subscription?: Subscription<any>) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map(source => subscribe(source, subscription!)))\n      case RESET:\n        // do nothing, we are stateless\n        return\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  } as Emitter<T>\n}\n\n/**\n * A convenience wrapper that emits only the distinct values from the passed Emitter. Wraps [[pipe]] and [[distinctUntilChanged]].\n *\n * ```ts\n * const foo = stream<number>()\n *\n * // this line...\n * const a = duc(foo)\n *\n * // is equivalent to this\n * const b = pipe(distinctUntilChanged(foo))\n * ```\n *\n * @param source The source emitter.\n * @param comparator optional custom comparison function for the two values.\n *\n * @typeParam T the type of the value emitted by the source.\n *\n * @returns the resulting emitter.\n */\nexport function duc<T>(source: Emitter<T>, comparator: Comparator<T> = defaultComparator): Emitter<T> {\n  return pipe(source, distinctUntilChanged(comparator))\n}\n\n/**\n * Creates an emitter with the latest values from all passed emitters as an array.\n *\n * `combineLatest` acts as a Depot. Using it on stateless streams persists the last emitted value of each [[Emitter]].\n * Provided that all emitters have emitted at least once, subscribing to the resulting emitter will immediately receive their combined latest values.\n *\n * ```ts\n * const foo = stream<number>()\n * const bar = stream<number>()\n *\n * subscribe(combineLatest(foo, bar), ([foo, bar]) => console.log({ foo, bar }))\n *\n * publish(foo, 42)\n * publish(bar, 43) // { foo: 42, bar: 43 }\n * publish(foo, 44) // { foo: 44, bar: 43 }\n * publish(bar, 45) // { foo: 44, bar: 45 }\n * ```\n */\nexport function combineLatest<O1, O2>(...emitters: [Emitter<O1>, Emitter<O2>]): Emitter<[O1, O2]> // prettier-ignore\nexport function combineLatest<O1, O2, O3>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>]): Emitter<[O1, O2, O3]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>]): Emitter<[O1, O2, O3, O4]> // prettier-ignore\nexport function combineLatest<O1, O2, O3>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>]): Emitter<[O1, O2, O3]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>]): Emitter<[O1, O2, O3, O4, O5]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>]): Emitter<[O1, O2, O3, O4, O5, O6]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>]): Emitter<[O1, O2, O3, O4, O5, O6, O7]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8, O9>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>, Emitter<O9>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8, O9]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8, O9, O10>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>, Emitter<O9>, Emitter<O10>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>, Emitter<O9>, Emitter<O10>, Emitter<O11>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11]> // prettier-ignore\nexport function combineLatest(...emitters: Emitter<any>[]): Emitter<any> {\n  let innerSubject = stream<any>()\n  const values = new Array(emitters.length)\n  let called = 0\n  const allCalled = Math.pow(2, emitters.length) - 1\n\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index)\n    subscribe(source, value => {\n      values[index] = value\n      called = called | bit\n      if (called === allCalled) {\n        publish(innerSubject, values)\n      }\n    })\n  })\n\n  return function(action: SUBSCRIBE | RESET, subscription?: Subscription<any>) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription!(values)\n        }\n        return subscribe(innerSubject, subscription!)\n      case RESET:\n        return reset(innerSubject)\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  } as Emitter<any>\n}\n","/**\n * ## Thinking in Systems\n * systems are a stateful **data-processing machines** which accept input through **input streams**,\n * init and maintain state in **depots** and, in certain conditions, emit values to subscriptions through **output streams**.\n * Systems can specify other systems as dependencies, and can act as singletons in the resulting dependency tree.\n *\n * ### Depots\n *\n * The first, and probably the most critical part to understand are **the depots**\n * mostly because they are somewhat implicit.\n * Unlike other state management paradigms, the depots are not kept in a single data structure.\n * Insted, depots are defined and maintained as stateful streams, stateful transfomers\n * like [[combineLatest]] or stateful operators like[ []withLatestFrom] or [[scan]].\n *\n * **Depots persist values over time**.\n * If it was not for them, the system had to re-receive its entire input state simultaneously in order to calculate the values for its output stream.\n *\n * Of course, strictly speaking, it is possible to implement a pure, stateless system as a form of a complex map/reduce. urx would not mind that ;).\n *\n * ### Input Streams\n *\n * The system receives updates from the rest of the world through values published in its input streams.\n * The streams used can be either stateless (acting as means to send **signals**) or stateful, where the initial stream state acts as the default value for that system parameter.\n *\n * The effects of the input streams are up to the system data-processing logic. It can change its depots' state, and/or emit values through its output streams.\n *\n * ### Data Processing\n *\n * The actual system behavior is exclusively implemented by **applying transformers and operators** to the input streams, producing the respective output streams.\n * In the final state the system streams are organized in a directed graph, where incoming data is routed through certain edges and nodes.\n * Simple systems like the one in [urx by example](https://urx.virtuoso.dev/docs/urx-by-example) can use a straightforward single-step transformation (in this case, `combineLatest` and `map`),\n * while complex ones can introduce multiple intermediate streams to model their logic.\n *\n * ### Output Streams\n *\n * The system publishes updates to its clients (other systems or an UI bound to it) by publishing data in its output streams.\n * State-reflecting output streams, like `sum` in the [urx by example](https://urx.virtuoso.dev/docs/urx-by-example) should use stateful streams as output streams.\n * Signal-like output should use regular, stateless streams. In general, stateless input streams tend to have a symmetrical stateless streams, and the opposite.\n *\n * @packageDocumentation\n */\nimport { Emitter } from './actions'\n\n/**\n * Systems are a dictionaries of streams. a [[SystemConstructor]] should return a System.\n */\nexport interface System {\n  [key: string]: Emitter<any>\n}\n\n/**\n * a SystemSpec is the result from a [[system]] call. To obtain the [[System]], pass the spec to [[init]].\n */\nexport interface SystemSpec<SS extends SystemSpecs, C extends SystemConstructor<SS>> {\n  id: string\n  constructor: C\n  dependencies: SS\n  singleton: boolean\n}\n\n/** @internal **/\nexport type AnySystemSpec = SystemSpec<any, any>\n\n/** @internal **/\nexport type SystemSpecs = AnySystemSpec[]\n\n/** @internal **/\nexport type SR<E extends AnySystemSpec, R extends System = ReturnType<E['constructor']>> = R\n\n/** @internal **/\nexport type SpecResults<SS extends SystemSpecs, L = SS['length']> = L extends 0\n  ? []\n  : L extends 1\n  ? [SR<SS[0]>]\n  : L extends 2\n  ? [SR<SS[0]>, SR<SS[1]>]\n  : L extends 3\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>]\n  : L extends 4\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>]\n  : L extends 5\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>]\n  : L extends 6\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>]\n  : L extends 7\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>]\n  : L extends 8\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>, SR<SS[7]>]\n  : L extends 9\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>, SR<SS[7]>, SR<SS[8]>]\n  : L extends 10\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>, SR<SS[7]>, SR<SS[8]>, SR<SS[9]>]\n  : L extends 11\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>, SR<SS[7]>, SR<SS[8]>, SR<SS[9]>, SR<SS[10]>]\n  : never\n\n/**\n * The system constructor is a function which initializes and connects streams and returns them as a [[System]].\n * If the [[system]] call specifies system dependencies, the constructor receives the dependencies as an array argument.\n */\nexport type SystemConstructor<D extends SystemSpecs> = (dependencies: SpecResults<D>) => System\n\n/**\n * `system` defines a specification of a system - its constructor, dependencies and if it should act as a singleton in a system dependency tree.\n * When called, system returns a [[SystemSpec]], which is then initialized along with its dependencies by passing it to [[init]].\n *\n * ```ts\n * @import { subscribe, publish, system, init, tup, connect, map, pipe } from 'urx'\n *\n * // a simple system with two streams\n * const sys1 = system(() => {\n *  const a = stream<number>()\n *  const b = stream<number>()\n *\n *  connect(pipe(a, map(value => value * 2)), b)\n *  return { a, b }\n * })\n *\n * // a second system which depends on the streams from the first one\n * const sys2 = system(([ {a, b} ]) => {\n *  const c = stream<number>()\n *  connect(pipe(b, map(value => value * 2)), c)\n *  // re-export the `a` stream, keep `b` internal\n *  return { a, c }\n * }, tup(sys1))\n *\n * // init will recursively initialize sys2 dependencies, in this case sys1\n * const { a, c } = init(sys2)\n * subscribe(c, c => console.log(`Value multiplied by 4`, c))\n * publish(a, 2)\n * ```\n *\n * #### Singletons in Dependency Tree\n *\n * By default, systems will be initialized only once if encountered multiple times in the dependency tree.\n * In the below dependency system tree, systems `b` and `c` will receive the same stream instances from system `a` when system `d` is initialized.\n * ```txt\n *   a\n *  / \\\n * b   c\n *  \\ /\n *   d\n * ```\n * If `a` gets `{singleton: false}` as a last argument, `init` creates two separate instances - one for `b` and one for `c`.\n *\n * @param constructor the system constructor function. Initialize and connect the streams in its body.\n *\n * @param dependencies the system dependencies, which the constructor will receive as arguments.\n * Use the [[tup]] utility **For TypeScript type inference to work correctly**.\n * ```ts\n * const sys3 = system(() => { ... }, tup(sys2, sys1))\n * ```\n * @param __namedParameters Options\n * @param singleton determines if the system will act as a singleton in a system dependency tree. `true` by default.\n */\nexport function system<F extends SystemConstructor<D>, D extends SystemSpecs>(\n  constructor: F,\n  dependencies: D = ([] as unknown) as D,\n  { singleton }: { singleton: boolean } = { singleton: true }\n): SystemSpec<D, F> {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton,\n  }\n}\n\n/** @internal */\nconst id = () => (Symbol() as unknown) as string\n\n/**\n * Initializes a [[SystemSpec]] by recursively initializing its dependencies.\n *\n * ```ts\n * // a simple system with two streams\n * const sys1 = system(() => {\n *  const a = stream<number>()\n *  const b = stream<number>()\n *\n *  connect(pipe(a, map(value => value * 2)), b)\n *  return { a, b }\n * })\n *\n * const { a, b } = init(sys1)\n * subscribe(b, b => console.log(b))\n * publish(a, 2)\n * ```\n *\n * @returns the [[System]] constructed by the spec constructor.\n * @param systemSpec the system spec to initialize.\n */\nexport function init<SS extends AnySystemSpec>(systemSpec: SS): SR<SS> {\n  const singletons = new Map<string, System>()\n  const _init = <SS extends AnySystemSpec>({ id, constructor, dependencies, singleton }: SS) => {\n    if (singleton && singletons.has(id)) {\n      return singletons.get(id)! as SR<SS>\n    }\n    const system = constructor(dependencies.map((e: AnySystemSpec) => _init(e)))\n    if (singleton) {\n      singletons.set(id, system)\n    }\n    return system as any\n  }\n  return _init(systemSpec)\n}\n","/**\n * `@virtuoso.dev/react-urx` exports the [[systemToComponent]] function.\n * It wraps urx systems in to UI **logic provider components**,\n * mapping the system input and output streams to the component input / output points.\n *\n * ### Simple System wrapped as React Component\n *\n * ```tsx\n * const sys = system(() => {\n *   const foo = statefulStream(42)\n *   return { foo }\n * })\n *\n * const { Component: MyComponent, useEmitterValue } = systemToComponent(sys, {\n *   required: { fooProp: 'foo' },\n * })\n *\n * const Child = () => {\n *   const foo = useEmitterValue('foo')\n *   return <div>{foo}</div>\n * }\n *\n * const App = () => {\n *   return <Comp fooProp={42}><Child /><Comp>\n * }\n * ```\n *\n * @packageDocumentation\n */\nimport * as React from 'react'\nimport {\n  ComponentType,\n  createContext,\n  createElement,\n  forwardRef,\n  ForwardRefExoticComponent,\n  ReactNode,\n  RefAttributes,\n  useContext,\n  useImperativeHandle,\n  useState,\n  useCallback,\n} from 'react'\nimport {\n  AnySystemSpec,\n  reset,\n  curry1to0,\n  curry2to1,\n  Emitter,\n  SR,\n  eventHandler,\n  getValue,\n  publish,\n  Publisher,\n  init,\n  StatefulStream,\n  Stream,\n  subscribe,\n  always,\n  tap,\n} from '@virtuoso.dev/urx'\n\n/** @internal */\ninterface Dict<T> {\n  [key: string]: T\n}\n\n/** @internal */\nfunction omit<O extends Dict<any>, K extends readonly string[]>(keys: K, obj: O): Omit<O, K[number]> {\n  var result = {} as Dict<any>\n  var index = {} as Dict<1>\n  var idx = 0\n  var len = keys.length\n\n  while (idx < len) {\n    index[keys[idx]] = 1\n    idx += 1\n  }\n\n  for (var prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop]\n    }\n  }\n\n  return result as any\n}\n\nconst useIsomorphicLayoutEffect = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\n/** @internal */\nexport type Observable<T> = Emitter<T> | Publisher<T>\n\n/**\n * Describes the mapping between the system streams and the component properties.\n * Each property uses the keys as the names of the properties and the values as the corresponding stream names.\n * @typeParam SS the type of the system.\n */\nexport interface SystemPropsMap<SS extends AnySystemSpec, K = keyof SR<SS>, D = { [key: string]: K }> {\n  /**\n   * Specifies the required component properties.\n   */\n  required?: D\n  /**\n   * Specifies the optional component properties.\n   */\n  optional?: D\n  /**\n   * Specifies the component methods, if any. Streams are converted to methods with a single argument.\n   * When invoked, the method publishes the value of the argument to the specified stream.\n   */\n  methods?: D\n  /**\n   * Specifies the component \"event\" properties, if any.\n   * Event properties accept callback functions which get executed when the stream emits a new value.\n   */\n  events?: D\n}\n\n/** @internal */\nexport type PropsFromPropMap<E extends AnySystemSpec, M extends SystemPropsMap<E>> = {\n  [K in Extract<keyof M['required'], string>]: M['required'][K] extends string\n    ? SR<E>[M['required'][K]] extends Observable<infer R>\n      ? R\n      : never\n    : never\n} &\n  {\n    [K in Extract<keyof M['optional'], string>]?: M['optional'][K] extends string\n      ? SR<E>[M['optional'][K]] extends Observable<infer R>\n        ? R\n        : never\n      : never\n  } &\n  {\n    [K in Extract<keyof M['events'], string>]?: M['events'][K] extends string\n      ? SR<E>[M['events'][K]] extends Observable<infer R>\n        ? (value: R) => void\n        : never\n      : never\n  }\n\n/** @internal */\nexport type MethodsFromPropMap<E extends AnySystemSpec, M extends SystemPropsMap<E>> = {\n  [K in Extract<keyof M['methods'], string>]: M['methods'][K] extends string\n    ? SR<E>[M['methods'][K]] extends Observable<infer R>\n      ? (value: R) => void\n      : never\n    : never\n}\n\n/**\n * Used to correctly specify type refs for system components\n *\n * ```tsx\n * const s = system(() => { return { a: statefulStream(0) } })\n * const { Component } = systemToComponent(s)\n *\n * const App = () => {\n *  const ref = useRef<RefHandle<typeof Component>>()\n *  return <Component ref={ref} />\n * }\n * ```\n *\n * @typeParam T the type of the component\n */\nexport type RefHandle<T> = T extends ForwardRefExoticComponent<RefAttributes<infer Handle>> ? Handle : never\n\n/**\n * Converts a system spec to React component by mapping the system streams to component properties, events and methods. Returns hooks for querying and modifying\n * the system streams from the component's child components.\n * @param systemSpec The return value from a [[system]] call.\n * @param map The streams to props / events / methods mapping Check [[SystemPropsMap]] for more details.\n * @param Root The optional React component to render. By default, the resulting component renders nothing, acting as a logical wrapper for its children.\n * @returns an object containing the following:\n *  - `Component`: the React component.\n *  - `useEmitterValue`: a hook that lets child components use values emitted from the specified output stream.\n *  - `useEmitter`: a hook that calls the provided callback whenever the specified stream emits a value.\n *  - `usePublisher`: a hook which lets child components publish values to the specified stream.\n *  <hr />\n */\nexport function systemToComponent<SS extends AnySystemSpec, M extends SystemPropsMap<SS>, S extends SR<SS>, R>(\n  systemSpec: SS,\n  map: M,\n  Root?: R\n) {\n  const requiredPropNames = Object.keys(map.required || {})\n  const optionalPropNames = Object.keys(map.optional || {})\n  const methodNames = Object.keys(map.methods || {})\n  const eventNames = Object.keys(map.events || {})\n  const Context = createContext<SR<SS>>(({} as unknown) as any)\n\n  type RootCompProps = R extends ComponentType<infer RP> ? RP : { children?: ReactNode }\n\n  type CompProps = PropsFromPropMap<SS, M> & RootCompProps\n\n  type CompMethods = MethodsFromPropMap<SS, M>\n\n  function applyPropsToSystem(system: ReturnType<SS['constructor']>, props: any) {\n    if (system['propsReady']) {\n      publish(system['propsReady'], false)\n    }\n\n    for (const requiredPropName of requiredPropNames) {\n      const stream = system[map.required![requiredPropName]]\n      publish(stream, (props as any)[requiredPropName])\n    }\n\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream = system[map.optional![optionalPropName]]\n        publish(stream, (props as any)[optionalPropName])\n      }\n    }\n\n    if (system['propsReady']) {\n      publish(system['propsReady'], true)\n    }\n  }\n\n  function buildMethods(system: ReturnType<SS['constructor']>) {\n    return methodNames.reduce((acc, methodName) => {\n      ;(acc as any)[methodName] = (value: any) => {\n        const stream = system[map.methods![methodName]]\n        publish(stream, value)\n      }\n      return acc\n    }, {} as CompMethods)\n  }\n\n  function buildEventHandlers(system: ReturnType<SS['constructor']>) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system[map.events![eventName]])\n      return handlers\n    }, {} as { [key: string]: Emitter<any> })\n  }\n\n  /**\n   * A React component generated from an urx system\n   */\n  const Component = forwardRef<CompMethods, CompProps>((propsWithChildren, ref) => {\n    const { children, ...props } = propsWithChildren as any\n\n    const [system] = useState(() => {\n      return tap(init(systemSpec), system => applyPropsToSystem(system, props))\n    })\n\n    const [handlers] = useState(curry1to0(buildEventHandlers, system))\n\n    useIsomorphicLayoutEffect(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName])\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset)\n      }\n    }, [props, handlers, system])\n\n    useIsomorphicLayoutEffect(() => {\n      applyPropsToSystem(system, props)\n    })\n\n    useImperativeHandle(ref, always(buildMethods(system)))\n\n    return createElement(\n      Context.Provider,\n      { value: system },\n      Root\n        ? createElement(\n            (Root as unknown) as ComponentType,\n            omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),\n            children\n          )\n        : children\n    )\n  })\n\n  const usePublisher = <K extends keyof S>(key: K) => {\n    return useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]) as (\n      value: S[K] extends Stream<infer R> ? R : never\n    ) => void\n  }\n\n  /**\n   * Returns the value emitted from the stream.\n   */\n  const useEmitterValue = <K extends keyof S, V = S[K] extends StatefulStream<infer R> ? R : never>(key: K) => {\n    const context = useContext(Context)\n    const source: StatefulStream<V> = context[key]\n\n    const [value, setValue] = useState(curry1to0(getValue, source))\n\n    useIsomorphicLayoutEffect(\n      () =>\n        subscribe(source, (next: V) => {\n          if (next !== value) {\n            setValue(always(next))\n          }\n        }),\n      [source, value]\n    )\n\n    return value\n  }\n\n  const useEmitter = <K extends keyof S, V = S[K] extends Stream<infer R> ? R : never>(key: K, callback: (value: V) => void) => {\n    const context = useContext(Context)\n    const source: Stream<V> = context[key]\n    useIsomorphicLayoutEffect(() => subscribe(source, callback), [callback, source])\n  }\n\n  return {\n    Component,\n    usePublisher,\n    useEmitterValue,\n    useEmitter,\n  }\n}\n","import { ListRange } from './interfaces'\n\nexport function tupleComparator(prev: [any, any] | undefined, current: [any, any]) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1])\n}\n\nexport function rangeComparator(prev: ListRange | undefined, next: ListRange) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex)\n}\n","import * as u from '@virtuoso.dev/urx'\n\nexport const UP = 'up' as const\nexport const DOWN = 'down' as const\nexport type ScrollDirection = typeof UP | typeof DOWN\n\nexport const domIOSystem = u.system(\n  () => {\n    const scrollTop = u.stream<number>()\n    const deviation = u.statefulStream(0)\n    const smoothScrollTargetReached = u.stream<true>()\n    const statefulScrollTop = u.statefulStream(0)\n    const viewportHeight = u.stream<number>()\n    const headerHeight = u.statefulStream(0)\n    const footerHeight = u.statefulStream(0)\n    const scrollTo = u.stream<ScrollToOptions>()\n    const scrollBy = u.stream<ScrollToOptions>()\n    const scrollingInProgress = u.statefulStream(false)\n\n    u.connect(scrollTop, statefulScrollTop)\n    const scrollDirection = u.statefulStream<ScrollDirection>(DOWN)\n\n    u.connect(\n      u.pipe(\n        scrollTop,\n        u.scan(\n          (acc, scrollTop) => {\n            return { direction: scrollTop < acc.prevScrollTop ? UP : DOWN, prevScrollTop: scrollTop }\n          },\n          { direction: DOWN, prevScrollTop: 0 } as { direction: ScrollDirection; prevScrollTop: number }\n        ),\n        u.map((value) => value.direction)\n      ),\n      scrollDirection\n    )\n\n    return {\n      // input\n      scrollTop,\n      viewportHeight,\n      headerHeight,\n      footerHeight,\n      smoothScrollTargetReached,\n\n      // signals\n      scrollTo,\n      scrollBy,\n\n      // state\n      scrollDirection,\n      statefulScrollTop,\n      deviation,\n      scrollingInProgress,\n    }\n  },\n  [],\n  { singleton: true }\n)\n","import * as u from '@virtuoso.dev/urx'\n\nexport const propsReadySystem = u.system(\n  () => {\n    const propsReady = u.statefulStream(false)\n\n    const didMount = u.streamFromEmitter(\n      u.pipe(\n        propsReady,\n        u.filter((ready) => ready),\n        u.distinctUntilChanged()\n      )\n    )\n\n    return { propsReady, didMount }\n  },\n  [],\n  { singleton: true }\n)\n","import * as u from '@virtuoso.dev/urx'\nimport { domIOSystem } from './domIOSystem'\n\nexport interface ListBottomInfo {\n  bottom: number\n  offsetBottom: number\n}\n\nexport interface AtBottomParams {\n  offsetBottom: number\n  scrollTop: number\n  viewportHeight: number\n  totalHeight: number\n}\n\nexport type NotAtBottomReason =\n  | 'SIZE_INCREASED'\n  | 'NOT_SHOWING_LAST_ITEM'\n  | 'VIEWPORT_HEIGHT_DECREASING'\n  | 'SCROLLING_UPWARDS'\n  | 'NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM'\n\nexport type AtBottomState =\n  | {\n      atBottom: false\n      notAtBottomBecause: NotAtBottomReason\n      state: AtBottomParams\n    }\n  | {\n      atBottom: true\n      state: AtBottomParams\n    }\n\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: 'NOT_SHOWING_LAST_ITEM',\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    totalHeight: 0,\n  },\n} as AtBottomState\n\nexport const stateFlagsSystem = u.system(([{ scrollTop, viewportHeight }]) => {\n  const isAtBottom = u.statefulStream(false)\n  const isAtTop = u.statefulStream(true)\n  const atBottomStateChange = u.stream<boolean>()\n  const atTopStateChange = u.stream<boolean>()\n  const listStateListener = u.stream<ListBottomInfo>()\n\n  // skip 1 to avoid an initial on/off flick\n  const isScrolling = u.streamFromEmitter(\n    u.pipe(\n      u.merge(u.pipe(u.duc(scrollTop), u.skip(1), u.mapTo(true)), u.pipe(u.duc(scrollTop), u.skip(1), u.mapTo(false), u.debounceTime(100))),\n      u.distinctUntilChanged()\n    )\n  )\n\n  u.connect(\n    u.pipe(\n      u.duc(scrollTop),\n      u.map((top) => top === 0),\n      u.distinctUntilChanged()\n    ),\n    isAtTop\n  )\n\n  u.connect(isAtTop, atTopStateChange)\n\n  const atBottomState = u.streamFromEmitter(\n    u.pipe(\n      u.combineLatest(listStateListener, u.duc(scrollTop), u.duc(viewportHeight)),\n      u.scan((current, [{ bottom, offsetBottom }, scrollTop, viewportHeight]) => {\n        const isAtBottom = offsetBottom === 0 && scrollTop + viewportHeight - bottom > -4\n        const state = {\n          viewportHeight,\n          scrollTop,\n          offsetBottom,\n          totalHeight: bottom + offsetBottom,\n        }\n\n        if (isAtBottom) {\n          return {\n            atBottom: true,\n            state,\n          } as AtBottomState\n        }\n\n        let notAtBottomBecause: NotAtBottomReason\n\n        if (state.totalHeight > current.state.totalHeight) {\n          notAtBottomBecause = 'SIZE_INCREASED'\n        } else if (offsetBottom !== 0) {\n          notAtBottomBecause = 'NOT_SHOWING_LAST_ITEM'\n        } else if (viewportHeight < current.state.viewportHeight) {\n          notAtBottomBecause = 'VIEWPORT_HEIGHT_DECREASING'\n        } else if (scrollTop < current.state.scrollTop) {\n          notAtBottomBecause = 'SCROLLING_UPWARDS'\n        } else {\n          notAtBottomBecause = 'NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM'\n        }\n\n        return {\n          atBottom: false,\n          notAtBottomBecause,\n          state,\n        } as AtBottomState\n      }, INITIAL_BOTTOM_STATE),\n      u.distinctUntilChanged((prev, next) => {\n        // prev && console.log(prev.atBottom, next.atBottom)\n        return prev && prev.atBottom === next.atBottom\n      })\n    )\n  )\n\n  u.connect(\n    u.pipe(\n      atBottomState,\n      u.map((state) => state.atBottom)\n    ),\n    isAtBottom\n  )\n\n  u.subscribe(isAtBottom, (value) => {\n    setTimeout(() => u.publish(atBottomStateChange, value))\n  })\n\n  // connect(isAtBottom, atBottomStateChange)\n\n  return { isScrolling, isAtTop, isAtBottom, atBottomState, atTopStateChange, atBottomStateChange, listStateListener }\n}, u.tup(domIOSystem))\n","import {\n  combineLatest,\n  connect,\n  distinctUntilChanged,\n  filter,\n  map,\n  mapTo,\n  pipe,\n  scan,\n  statefulStream,\n  stream,\n  subscribe,\n  system,\n  throttleTime,\n  tup,\n  withLatestFrom,\n} from '@virtuoso.dev/urx'\nimport { domIOSystem } from './domIOSystem'\nimport { ListRange } from './interfaces'\nimport { stateFlagsSystem } from './stateFlagsSystem'\nimport { ScrollSeekConfiguration } from './interfaces'\n\nexport const scrollSeekSystem = system(\n  ([{ scrollTop }, { isScrolling }]) => {\n    const scrollVelocity = statefulStream(0)\n    const isSeeking = statefulStream(false)\n    const rangeChanged = stream<ListRange>()\n    const scrollSeekConfiguration = statefulStream<ScrollSeekConfiguration | undefined | false>(false)\n\n    connect(\n      pipe(\n        isScrolling,\n        filter((value) => !value),\n        mapTo(0)\n      ),\n      scrollVelocity\n    )\n\n    connect(\n      pipe(\n        scrollTop,\n        throttleTime(100),\n        withLatestFrom(isScrolling),\n        filter(([_, isScrolling]) => !!isScrolling),\n        scan(([_, prev], [next]) => [prev, next], [0, 0]),\n        map(([prev, next]) => next - prev)\n      ),\n      scrollVelocity\n    )\n\n    connect(\n      pipe(\n        scrollVelocity,\n        withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged),\n        filter(([_, config]) => !!config),\n        map(([speed, config, isSeeking, range]) => {\n          const { exit, enter } = config as ScrollSeekConfiguration\n          if (isSeeking) {\n            if (exit(speed, range)) {\n              return false\n            }\n          } else {\n            if (enter(speed, range)) {\n              return true\n            }\n          }\n          return isSeeking\n        }),\n        distinctUntilChanged()\n      ),\n      isSeeking\n    )\n\n    subscribe(\n      pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)),\n      ([[isSeeking, velocity, range], config]) => isSeeking && config && config.change && config.change(velocity, range)\n    )\n\n    return { isSeeking, scrollSeekConfiguration, scrollVelocity, scrollSeekRangeChanged: rangeChanged }\n  },\n  tup(domIOSystem, stateFlagsSystem),\n  { singleton: true }\n)\n","interface NilNode {\n  lvl: 0\n}\n\nconst NIL_NODE: NilNode = { lvl: 0 }\n\ninterface NodeData<T> {\n  k: number\n  v: T\n}\n\ninterface NonNilAANode<T> {\n  k: number\n  v: T\n  lvl: number\n  l: NonNilAANode<T> | NilNode\n  r: NonNilAANode<T> | NilNode\n}\n\nexport interface Range<T> {\n  start: number\n  end: number\n  value: T\n}\n\nexport type AANode<T> = NilNode | NonNilAANode<T>\n\nfunction newAANode<T>(k: number, v: T, lvl: number, l: AANode<T> = NIL_NODE, r: AANode<T> = NIL_NODE): NonNilAANode<T> {\n  return { k, v, lvl, l, r }\n}\n\nexport function empty(node: AANode<any>): node is NilNode {\n  return node === NIL_NODE\n}\n\nexport function newTree<T>(): AANode<T> {\n  return NIL_NODE\n}\n\nexport function remove<T>(node: AANode<T>, key: number): AANode<T> {\n  if (empty(node)) return NIL_NODE\n\n  const { k, l, r } = node\n\n  if (key === k) {\n    if (empty(l)) {\n      return r\n    } else if (empty(r)) {\n      return l\n    } else {\n      const [lastKey, lastValue] = last(l)\n      return adjust(clone(node, { k: lastKey, v: lastValue, l: deleteLast(l) }))\n    }\n  } else if (key < k) {\n    return adjust(clone(node, { l: remove(l, key) }))\n  } else {\n    return adjust(clone(node, { r: remove(r, key) }))\n  }\n}\n\nexport function find<T>(node: AANode<T>, key: number): T | undefined {\n  if (empty(node)) {\n    return\n  }\n\n  if (key === node.k) {\n    return node.v\n  } else if (key < node.k) {\n    return find(node.l, key)\n  } else {\n    return find(node.r, key)\n  }\n}\n\nexport function findMaxKeyValue<T>(node: AANode<T>, value: number, field: 'k' | 'v' = 'k'): [number, T | undefined] {\n  if (empty(node)) {\n    return [-Infinity, undefined]\n  }\n\n  if (node[field] === value) {\n    return [node.k, node.v]\n  }\n\n  if (node[field] < value) {\n    const r = findMaxKeyValue(node.r, value, field)\n    if (r[0] === -Infinity) {\n      return [node.k, node.v]\n    } else {\n      return r\n    }\n  }\n\n  return findMaxKeyValue(node.l, value, field)\n}\n\nexport function insert<T>(node: AANode<T>, k: number, v: T): NonNilAANode<T> {\n  if (empty(node)) {\n    return newAANode(k, v, 1)\n  }\n  if (k === node.k) {\n    return clone(node, { k, v })\n  } else if (k < node.k) {\n    return rebalance(clone(node, { l: insert(node.l, k, v) }))\n  } else {\n    return rebalance(clone(node, { r: insert(node.r, k, v) }))\n  }\n}\n\nexport function walkWithin<T>(node: AANode<T>, start: number, end: number): NodeData<T>[] {\n  if (empty(node)) {\n    return []\n  }\n\n  const { k, v, l, r } = node\n  let result: NodeData<T>[] = []\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end))\n  }\n\n  if (k >= start && k <= end) {\n    result.push({ k, v })\n  }\n\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end))\n  }\n\n  return result\n}\n\nexport function walk<T>(node: AANode<T>): NodeData<T>[] {\n  if (empty(node)) {\n    return []\n  }\n\n  return [...walk(node.l), { k: node.k, v: node.v }, ...walk(node.r)]\n}\n\nfunction last<T>(node: NonNilAANode<T>): [number, T] {\n  return empty(node.r) ? [node.k, node.v] : last(node.r)\n}\n\nfunction deleteLast<T>(node: NonNilAANode<T>): AANode<T> {\n  return empty(node.r) ? node.l : adjust(clone(node, { r: deleteLast(node.r) }))\n}\n\nfunction clone<T>(node: NonNilAANode<T>, args: Partial<NonNilAANode<T>>): NonNilAANode<T> {\n  return newAANode(\n    args.k !== undefined ? args.k : node.k,\n    args.v !== undefined ? args.v : node.v,\n    args.lvl !== undefined ? args.lvl : node.lvl,\n    args.l !== undefined ? args.l : node.l,\n    args.r !== undefined ? args.r : node.r\n  )\n}\n\nfunction isSingle(node: AANode<any>) {\n  return empty(node) || node.lvl > node.r.lvl\n}\n\nfunction rebalance<T>(node: NonNilAANode<T>): NonNilAANode<T> {\n  return split(skew(node))\n}\n\nfunction adjust<T>(node: NonNilAANode<T>): NonNilAANode<T> {\n  const { l, r, lvl } = node\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, { lvl: lvl - 1 }))\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, { r: l.r.l }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1,\n          }),\n          lvl: lvl,\n        })\n      } else {\n        throw new Error('Unexpected empty nodes')\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, { lvl: lvl - 1 }))\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl\n\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1,\n          }),\n          r: split(clone(r, { l: rl.r, lvl: rlvl })),\n          lvl: rl.lvl + 1,\n        })\n      } else {\n        throw new Error('Unexpected empty nodes')\n      }\n    }\n  }\n}\n\nexport function keys(node: AANode<any>): number[] {\n  if (empty(node)) {\n    return []\n  }\n  return [...keys(node.l), node.k, ...keys(node.r)]\n}\n\nexport function ranges<T>(node: AANode<T>): Range<T>[] {\n  return toRanges(walk(node))\n}\n\nexport function rangesWithin<T>(node: AANode<T>, startIndex: number, endIndex: number): Range<T>[] {\n  if (empty(node)) {\n    return []\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0]\n  return toRanges(walkWithin(node, adjustedStart, endIndex))\n}\n\nexport function arrayToRanges<T, V>(\n  items: T[],\n  parser: (item: T) => { index: number; value: V }\n): Array<{ start: number; end: number; value: V }> {\n  const length = items.length\n  if (length === 0) {\n    return []\n  }\n\n  let { index: start, value } = parser(items[0])\n\n  const result = []\n\n  for (let i = 1; i < length; i++) {\n    const { index: nextIndex, value: nextValue } = parser(items[i])\n    result.push({ start, end: nextIndex - 1, value })\n\n    start = nextIndex\n    value = nextValue\n  }\n\n  result.push({ start, end: Infinity, value })\n  return result\n}\n\nfunction toRanges<T>(nodes: NodeData<T>[]): Range<T>[] {\n  return arrayToRanges(nodes, ({ k: index, v: value }) => ({ index, value }))\n}\n\nfunction split<T>(node: NonNilAANode<T>): NonNilAANode<T> {\n  const { r, lvl } = node\n\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, { l: clone(node, { r: r.l }), lvl: lvl + 1 }) : node\n}\n\nfunction skew<T>(node: NonNilAANode<T>): NonNilAANode<T> {\n  const { l } = node\n\n  return !empty(l) && l.lvl === node.lvl ? clone(l, { r: clone(node, { l: l.r }) }) : node\n}\n","export type Comparator<T> = {\n  (item: T, value: number): -1 | 0 | 1\n}\n\nexport function findIndexOfClosestSmallerOrEqual<T>(items: T[], value: number, comparator: Comparator<T>, start = 0): number {\n  let end = items.length - 1\n\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2)\n    const item = items[index]\n    const match = comparator(item, value)\n    if (match === 0) {\n      return index\n    }\n\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1\n      }\n      end = index - 1\n    } else {\n      if (end === start) {\n        return index\n      }\n      start = index + 1\n    }\n  }\n\n  throw new Error(`Failed binary finding record in array - ${items.join(',')}, searched for ${value}`)\n}\n\nexport function findClosestSmallerOrEqual<T>(items: T[], value: number, comparator: Comparator<T>): T {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)]\n}\n\nexport function findRange<T>(items: T[], startValue: number, endValue: number, comparator: Comparator<T>): T[] {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator)\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex)\n  return items.slice(startIndex, endIndex + 1)\n}\n","import * as u from '@virtuoso.dev/urx'\nimport { arrayToRanges, AANode, empty, findMaxKeyValue, insert, newTree, Range, rangesWithin, remove, walk } from './AATree'\nimport * as arrayBinarySearch from './utils/binaryArraySearch'\n\nexport interface SizeRange {\n  startIndex: number\n  endIndex: number\n  size: number\n}\n\nexport type Data = readonly unknown[] | undefined\n\nfunction rangeIncludes(refRange: SizeRange) {\n  const { size, startIndex, endIndex } = refRange\n  return (range: Range<number>) => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size\n  }\n}\n\nexport function insertRanges(sizeTree: AANode<number>, ranges: SizeRange[]) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity\n\n  for (const range of ranges) {\n    const { size, startIndex, endIndex } = range\n    syncStart = Math.min(syncStart, startIndex)\n\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size)\n      continue\n    }\n\n    // extend the range in both directions, so that we can get adjacent neighbours.\n    // if the previous / next ones have the same value as the one we are about to insert,\n    // we 'merge' them.\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1)\n\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue\n    }\n\n    let firstPassDone = false\n    let shouldInsert = false\n    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges) {\n      // previous range\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size\n        firstPassDone = true\n      } else {\n        // remove the range if it starts within the new range OR if\n        // it has the same value as it, in order to perform a merge\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart)\n        }\n      }\n\n      // next range\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue)\n        }\n      }\n    }\n\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size)\n    }\n  }\n  return [sizeTree, syncStart] as const\n}\n\nexport interface OffsetPoint {\n  offset: number\n  size: number\n  index: number\n}\n\nexport interface SizeState {\n  sizeTree: AANode<number>\n  offsetTree: Array<OffsetPoint>\n  groupOffsetTree: AANode<number>\n  lastIndex: number\n  lastOffset: number\n  lastSize: number\n  groupIndices: number[]\n}\n\nexport function initialSizeState(): SizeState {\n  return {\n    offsetTree: [],\n    sizeTree: newTree<number>(),\n    groupOffsetTree: newTree<number>(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: [],\n  }\n}\n\nexport function indexComparator({ index: itemIndex }: OffsetPoint, index: number) {\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1\n}\n\nexport function offsetComparator({ offset: itemOffset }: OffsetPoint, offset: number) {\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1\n}\n\nfunction offsetPointParser(point: OffsetPoint) {\n  return { index: point.index, value: point }\n}\n\nexport function rangesWithinOffsets(\n  tree: Array<OffsetPoint>,\n  startOffset: number,\n  endOffset: number,\n  minStartIndex = 0\n): Array<{\n  start: number\n  end: number\n  value: {\n    size: number\n    offset: number\n    index: number\n  }\n}> {\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, arrayBinarySearch.findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset)\n  }\n\n  return arrayToRanges(arrayBinarySearch.findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser)\n}\n\nexport function sizeStateReducer(state: SizeState, [ranges, groupIndices]: [SizeRange[], number[]]) {\n  const sizeTree = state.sizeTree\n  let offsetTree = state.offsetTree\n  let newSizeTree: AANode<number> = sizeTree\n  let syncStart = 0\n\n  // We receive probe item results from a group probe,\n  // which should always pass an item and a group\n  // the results contain two ranges, which we consider to mean that groups and items have different size\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size\n    const itemSize = ranges[1].size\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize)\n    }, newSizeTree)\n  } else {\n    ;[newSizeTree, syncStart] = insertRanges(newSizeTree, ranges)\n  }\n\n  if (newSizeTree === sizeTree) {\n    return state\n  }\n\n  let prevIndex = 0\n  let prevSize = 0\n\n  let prevAOffset = 0\n  let startAIndex = 0\n\n  if (syncStart !== 0) {\n    startAIndex = arrayBinarySearch.findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator)\n    const offsetInfo = offsetTree[startAIndex]\n    prevAOffset = offsetInfo.offset\n    const kv = findMaxKeyValue(newSizeTree, syncStart - 1)\n    prevIndex = kv[0]\n    prevSize = kv[1]!\n\n    if (offsetTree.length && offsetTree[startAIndex].size === findMaxKeyValue(newSizeTree, syncStart)[1]) {\n      startAIndex -= 1\n    }\n\n    offsetTree = offsetTree.slice(0, startAIndex + 1)\n  } else {\n    offsetTree = []\n  }\n\n  for (const { start: startIndex, value } of rangesWithin(newSizeTree, syncStart, Infinity)) {\n    const aOffset = (startIndex - prevIndex) * prevSize + prevAOffset\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex,\n    })\n    prevIndex = startIndex\n    prevAOffset = aOffset\n    prevSize = value\n  }\n\n  return {\n    sizeTree: newSizeTree,\n    offsetTree,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, offsetTree))\n    }, newTree<number>()),\n    lastIndex: prevIndex,\n    lastOffset: prevAOffset,\n    lastSize: prevSize,\n    groupIndices,\n  }\n}\n\nexport function offsetOf(index: number, tree: Array<OffsetPoint>) {\n  if (tree.length === 0) {\n    return 0\n  }\n\n  const { offset, index: startIndex, size } = arrayBinarySearch.findClosestSmallerOrEqual(tree, index, indexComparator)\n  return size * (index - startIndex) + offset\n}\n\nexport function originalIndexFromItemIndex(itemIndex: number, sizes: SizeState) {\n  if (!hasGroups(sizes)) {\n    return itemIndex\n  }\n\n  let groupOffset = 0\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++\n  }\n  // we find the real item index, offsetting it by the number of group items before it\n  return itemIndex + groupOffset\n}\n\nexport function hasGroups(sizes: SizeState) {\n  return !empty(sizes.groupOffsetTree)\n}\n\ntype OptionalNumber = number | undefined\nexport const sizeSystem = u.system(\n  () => {\n    const sizeRanges = u.stream<SizeRange[]>()\n    const totalCount = u.stream<number>()\n    const unshiftWith = u.stream<number>()\n    const firstItemIndex = u.statefulStream(0)\n    const groupIndices = u.statefulStream([] as number[])\n    const fixedItemSize = u.statefulStream<OptionalNumber>(undefined)\n    const defaultItemSize = u.statefulStream<OptionalNumber>(undefined)\n    const data = u.statefulStream<Data>(undefined)\n    const initial = initialSizeState()\n\n    const sizes = u.statefulStreamFromEmitter(\n      u.pipe(sizeRanges, u.withLatestFrom(groupIndices), u.scan(sizeStateReducer, initial), u.distinctUntilChanged()),\n      initial\n    )\n\n    u.connect(\n      u.pipe(\n        groupIndices,\n        u.filter((indexes) => indexes.length > 0),\n        u.withLatestFrom(sizes),\n        u.map(([groupIndices, sizes]) => {\n          const groupOffsetTree = groupIndices.reduce((tree, index, idx) => {\n            return insert(tree, index, offsetOf(index, sizes.offsetTree) || idx)\n          }, newTree<number>())\n\n          return {\n            ...sizes,\n            groupIndices,\n            groupOffsetTree,\n          }\n        })\n      ),\n      sizes\n    )\n\n    // decreasing the total count should remove any existing entries\n    // beyond the last index - do this by publishing the default size as a range over them.\n    u.connect(\n      u.pipe(\n        totalCount,\n        u.withLatestFrom(sizes),\n        u.filter(([totalCount, { lastIndex }]) => {\n          return totalCount < lastIndex\n        }),\n        u.map(([totalCount, { lastIndex, lastSize }]) => {\n          return [\n            {\n              startIndex: totalCount,\n              endIndex: lastIndex,\n              size: lastSize,\n            },\n          ] as SizeRange[]\n        })\n      ),\n      sizeRanges\n    )\n\n    u.connect(fixedItemSize, defaultItemSize)\n\n    const trackItemSizes = u.statefulStreamFromEmitter(\n      u.pipe(\n        fixedItemSize,\n        u.map((size) => size === undefined)\n      ),\n      true\n    )\n\n    u.connect(\n      u.pipe(\n        defaultItemSize,\n        u.filter((value) => value !== undefined),\n        u.map((size) => [{ startIndex: 0, endIndex: 0, size }] as SizeRange[])\n      ),\n      sizeRanges\n    )\n\n    const listRefresh = u.streamFromEmitter(\n      u.pipe(\n        sizeRanges,\n        u.withLatestFrom(sizes),\n        u.scan(\n          ({ sizes: oldSizes }, [_, newSizes]) => {\n            return {\n              changed: newSizes !== oldSizes,\n              sizes: newSizes,\n            }\n          },\n          { changed: false, sizes: initial }\n        ),\n        u.map((value) => value.changed)\n      )\n    )\n\n    u.connect(\n      u.pipe(\n        firstItemIndex,\n        u.scan(\n          (prev, next) => {\n            return { diff: prev.prev - next, prev: next }\n          },\n          { diff: 0, prev: 0 }\n        ),\n        u.map((val) => val.diff),\n        u.filter((value) => value > 0)\n      ),\n      unshiftWith\n    )\n\n    // Capture the current list top item before the sizes get refreshed\n    const beforeUnshiftWith = u.streamFromEmitter(unshiftWith)\n\n    u.connect(\n      u.pipe(\n        unshiftWith,\n        u.withLatestFrom(sizes),\n        u.map(([unshiftWith, sizes]) => {\n          if (sizes.groupIndices.length > 0) {\n            throw new Error('Virtuoso: prepending items does not work with groups')\n          }\n\n          return walk(sizes.sizeTree).reduce(\n            (acc, { k: index, v: size }) => {\n              return {\n                ranges: [...acc.ranges, { startIndex: acc.prevIndex, endIndex: index + unshiftWith - 1, size: acc.prevSize }],\n                prevIndex: index + unshiftWith,\n                prevSize: size,\n              }\n            },\n            {\n              ranges: [] as SizeRange[],\n              prevIndex: 0,\n              prevSize: sizes.lastSize,\n            }\n          ).ranges\n        })\n      ),\n      sizeRanges\n    )\n\n    return {\n      // input\n      data,\n      totalCount,\n      sizeRanges,\n      groupIndices,\n      defaultItemSize,\n      fixedItemSize,\n      unshiftWith,\n      beforeUnshiftWith,\n      firstItemIndex,\n\n      // output\n      sizes,\n      listRefresh,\n      trackItemSizes,\n    }\n  },\n  [],\n  { singleton: true }\n)\n","/* eslint-disable @typescript-eslint/no-unsafe-call */\nimport * as u from '@virtuoso.dev/urx'\nimport { findMaxKeyValue } from './AATree'\nimport { domIOSystem } from './domIOSystem'\nimport { offsetOf, originalIndexFromItemIndex, sizeSystem } from './sizeSystem'\nimport { IndexLocationWithAlign } from './interfaces'\n\nexport type IndexLocation = number | IndexLocationWithAlign\n\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== 'undefined' && 'scrollBehavior' in document.documentElement.style\n\nexport function normalizeIndexLocation(location: IndexLocation) {\n  const result: IndexLocationWithAlign = typeof location === 'number' ? { index: location } : location\n\n  if (!result.align) {\n    result.align = 'start'\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = 'auto'\n  }\n  if (!result.offset) {\n    result.offset = 0\n  }\n  return result as Required<IndexLocationWithAlign>\n}\n\nexport const scrollToIndexSystem = u.system(\n  ([\n    { sizes, totalCount, listRefresh },\n    { scrollingInProgress, viewportHeight, scrollTo, smoothScrollTargetReached, headerHeight, footerHeight },\n  ]) => {\n    const scrollToIndex = u.stream<IndexLocation>()\n    const topListHeight = u.statefulStream(0)\n\n    let unsubscribeNextListRefresh: any = null\n    let cleartTimeoutRef: any = null\n    let unsubscribeListRefresh: any = null\n\n    const cleanup = () => {\n      if (unsubscribeNextListRefresh) {\n        unsubscribeNextListRefresh()\n        unsubscribeNextListRefresh = null\n      }\n\n      if (unsubscribeListRefresh) {\n        unsubscribeListRefresh()\n        unsubscribeListRefresh = null\n      }\n\n      if (cleartTimeoutRef) {\n        clearTimeout(cleartTimeoutRef)\n        cleartTimeoutRef = null\n      }\n      u.publish(scrollingInProgress, false)\n    }\n\n    u.connect(\n      u.pipe(\n        scrollToIndex,\n        u.withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight),\n        u.map(([location, sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight]) => {\n          const normalLocation = normalizeIndexLocation(location)\n          const { align, behavior, offset } = normalLocation\n          const lastIndex = totalCount - 1\n          let index = normalLocation.index\n\n          index = originalIndexFromItemIndex(index, sizes)\n\n          index = Math.max(0, index, Math.min(lastIndex, index))\n\n          let top = offsetOf(index, sizes.offsetTree) + headerHeight\n          if (align === 'end') {\n            top = Math.round(top - viewportHeight + findMaxKeyValue(sizes.sizeTree, index)[1]!)\n            if (index === lastIndex) {\n              top += footerHeight\n            }\n          } else if (align === 'center') {\n            top = Math.round(top - viewportHeight / 2 + findMaxKeyValue(sizes.sizeTree, index)[1]! / 2)\n          } else {\n            top -= topListHeight\n          }\n\n          if (offset) {\n            top += offset\n          }\n\n          const retry = (listChanged: boolean) => {\n            cleanup()\n            if (listChanged) {\n              u.publish(scrollToIndex, location)\n            }\n          }\n\n          cleanup()\n\n          if (behavior === 'smooth') {\n            let listChanged = false\n            unsubscribeListRefresh = u.subscribe(listRefresh, (changed) => {\n              listChanged = listChanged || changed\n            })\n\n            unsubscribeNextListRefresh = u.handleNext(smoothScrollTargetReached, () => {\n              retry(listChanged)\n            })\n          } else {\n            unsubscribeNextListRefresh = u.handleNext(listRefresh, retry)\n          }\n\n          // if the scroll jump is too small, the list won't get rerendered.\n          // clean this listener\n          cleartTimeoutRef = setTimeout(() => {\n            cleanup()\n          }, 1200)\n\n          u.publish(scrollingInProgress, true)\n          return { top, behavior }\n        })\n      ),\n      scrollTo\n    )\n\n    return {\n      scrollToIndex,\n      topListHeight,\n    }\n  },\n  u.tup(sizeSystem, domIOSystem),\n  { singleton: true }\n)\n","import * as u from '@virtuoso.dev/urx'\nimport { domIOSystem, DOWN, ScrollDirection, UP } from './domIOSystem'\nimport { tupleComparator } from './comparators'\n\nexport type NumberTuple = [number, number]\nexport type Overscan = number | { main: number; reverse: number }\nexport const TOP = 'top' as const\nexport const BOTTOM = 'bottom' as const\nexport const NONE = 'none' as const\nexport type ListEnd = typeof TOP | typeof BOTTOM\nexport type ChangeDirection = typeof UP | typeof DOWN | typeof NONE\n\nexport const getOverscan = (overscan: Overscan, end: ListEnd, direction: ScrollDirection) => {\n  if (typeof overscan === 'number') {\n    return (direction === UP && end === TOP) || (direction === DOWN && end === BOTTOM) ? overscan : 0\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse\n    }\n  }\n}\n\nexport const sizeRangeSystem = u.system(\n  ([{ scrollTop, viewportHeight, deviation, headerHeight }]) => {\n    const listBoundary = u.stream<NumberTuple>()\n    const topListHeight = u.statefulStream(0)\n    const overscan = u.statefulStream<Overscan>(0)\n\n    const visibleRange = (u.statefulStreamFromEmitter(\n      u.pipe(\n        u.combineLatest(\n          u.duc(scrollTop),\n          u.duc(viewportHeight),\n          u.duc(headerHeight),\n          u.duc(listBoundary, tupleComparator),\n          u.duc(overscan),\n          u.duc(topListHeight),\n          u.duc(deviation)\n        ),\n        u.map(([scrollTop, viewportHeight, headerHeight, [listTop, listBottom], overscan, topListHeight, deviation]) => {\n          const top = scrollTop - headerHeight - deviation\n          let direction: ChangeDirection = NONE\n\n          listTop -= deviation\n          listBottom -= deviation\n\n          if (listTop > scrollTop + topListHeight) {\n            direction = UP\n          }\n\n          if (listBottom < scrollTop + viewportHeight) {\n            direction = DOWN\n          }\n\n          if (direction !== NONE) {\n            return [\n              Math.max(top - getOverscan(overscan, TOP, direction), 0),\n              top + viewportHeight + getOverscan(overscan, BOTTOM, direction),\n            ] as NumberTuple\n          }\n\n          return null\n        }),\n        u.filter((value) => value != null),\n        u.distinctUntilChanged(tupleComparator as any)\n      ),\n      [0, 0]\n    ) as unknown) as u.StatefulStream<NumberTuple>\n\n    return {\n      // input\n      listBoundary,\n      overscan,\n      topListHeight,\n\n      // output\n      visibleRange,\n    }\n  },\n  u.tup(domIOSystem),\n  { singleton: true }\n)\n","import * as u from '@virtuoso.dev/urx'\nimport { domIOSystem } from './domIOSystem'\nimport { WindowViewportInfo } from './interfaces'\n\nexport const windowScrollerSystem = u.system(([{ scrollTop, scrollTo }]) => {\n  const windowViewportRect = u.stream<WindowViewportInfo>()\n  const windowScrollTop = u.stream<number>()\n  const windowScrollTo = u.stream<ScrollToOptions>()\n  const useWindowScroll = u.statefulStream(false)\n\n  u.connect(\n    u.pipe(\n      u.combineLatest(windowScrollTop, windowViewportRect),\n      u.map(([windowScrollTop, { offsetTop }]) => {\n        return Math.max(0, windowScrollTop - offsetTop)\n      })\n    ),\n    scrollTop\n  )\n\n  u.connect(\n    u.pipe(\n      scrollTo,\n      u.withLatestFrom(windowViewportRect),\n      u.map(([scrollTo, { offsetTop }]) => {\n        return {\n          ...scrollTo,\n          top: scrollTo.top! + offsetTop,\n        }\n      })\n    ),\n    windowScrollTo\n  )\n\n  return {\n    // config\n    useWindowScroll,\n\n    // input\n    windowScrollTop,\n    windowViewportRect,\n\n    // signals\n    windowScrollTo,\n  }\n}, u.tup(domIOSystem))\n","import * as u from '@virtuoso.dev/urx'\nimport { rangeComparator, tupleComparator } from './comparators'\nimport { domIOSystem } from './domIOSystem'\nimport { propsReadySystem } from './propsReadySystem'\nimport { scrollSeekSystem } from './scrollSeekSystem'\nimport { IndexLocation, normalizeIndexLocation } from './scrollToIndexSystem'\nimport { sizeRangeSystem } from './sizeRangeSystem'\nimport { stateFlagsSystem } from './stateFlagsSystem'\nimport { windowScrollerSystem } from './windowScrollerSystem'\n\nexport interface ElementDimensions {\n  width: number\n  height: number\n}\n\nexport interface GridItem {\n  index: number\n}\n\nexport interface GridLayout {\n  top: number\n  bottom: number\n}\n\nexport interface GridState extends GridLayout {\n  items: GridItem[]\n  offsetTop: number\n  offsetBottom: number\n  itemHeight: number\n  itemWidth: number\n}\n\nconst INITIAL_GRID_STATE: GridState = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0,\n}\n\nconst PROBE_GRID_STATE: GridState = {\n  items: [{ index: 0 }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0,\n}\n\nconst { ceil, floor, min, max } = Math\n\nfunction hackFloor(val: number) {\n  return ceil(val) - val < 0.03 ? ceil(val) : floor(val)\n}\n\nfunction buildItems(startIndex: number, endIndex: number) {\n  return Array.from({ length: endIndex - startIndex + 1 }).map((_, i) => ({ index: i + startIndex } as GridItem))\n}\nexport const gridSystem = u.system(\n  ([\n    { overscan, visibleRange, listBoundary },\n    { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached },\n    stateFlags,\n    scrollSeek,\n    { propsReady, didMount },\n    { windowViewportRect, windowScrollTo, useWindowScroll, windowScrollTop },\n  ]) => {\n    const totalCount = u.statefulStream(0)\n    const initialItemCount = u.statefulStream(0)\n    const gridState = u.statefulStream(INITIAL_GRID_STATE)\n    const viewportDimensions = u.statefulStream<ElementDimensions>({ height: 0, width: 0 })\n    const itemDimensions = u.statefulStream<ElementDimensions>({ height: 0, width: 0 })\n    const scrollToIndex = u.stream<IndexLocation>()\n\n    u.connect(\n      u.pipe(\n        didMount,\n        u.withLatestFrom(initialItemCount),\n        u.filter(([, count]) => count !== 0),\n        u.map(([, count]) => {\n          return {\n            items: buildItems(0, count - 1),\n            top: 0,\n            bottom: 0,\n            offsetBottom: 0,\n            offsetTop: 0,\n            itemHeight: 0,\n            itemWidth: 0,\n          }\n        })\n      ),\n      gridState\n    )\n\n    u.connect(\n      u.pipe(\n        u.combineLatest(\n          u.duc(totalCount),\n          visibleRange,\n          u.duc(itemDimensions, (prev, next) => prev && prev.width === next.width && prev.height === next.height)\n        ),\n        u.withLatestFrom(viewportDimensions),\n        u.map(([[totalCount, [startOffset, endOffset], item], viewport]) => {\n          const { height: itemHeight, width: itemWidth } = item\n          const { width: viewportWidth } = viewport\n\n          if (totalCount === 0 || viewportWidth === 0) {\n            return INITIAL_GRID_STATE\n          }\n\n          if (itemWidth === 0) {\n            return PROBE_GRID_STATE\n          }\n\n          const perRow = hackFloor(viewportWidth / itemWidth)\n          let startIndex = perRow * floor(startOffset / itemHeight)\n          let endIndex = perRow * ceil(endOffset / itemHeight) - 1\n          endIndex = min(totalCount - 1, endIndex)\n          startIndex = min(endIndex, max(0, startIndex))\n\n          const items = buildItems(startIndex, endIndex)\n          const { top, bottom } = gridLayout(viewport, item, items)\n          const totalHeight = ceil(totalCount / perRow) * itemHeight\n          const offsetBottom = totalHeight - bottom\n\n          return { items, offsetTop: top, offsetBottom, top, bottom, itemHeight, itemWidth } as GridState\n        })\n      ),\n      gridState\n    )\n\n    u.connect(\n      u.pipe(\n        viewportDimensions,\n        u.map(({ height }) => height)\n      ),\n      viewportHeight\n    )\n\n    u.connect(\n      u.pipe(\n        u.combineLatest(viewportDimensions, itemDimensions, gridState),\n        u.map(([viewportDimensions, item, { items }]) => {\n          const { top, bottom } = gridLayout(viewportDimensions, item, items)\n\n          return [top, bottom] as [number, number]\n        }),\n        u.distinctUntilChanged(tupleComparator)\n      ),\n      listBoundary\n    )\n\n    u.connect(\n      u.pipe(\n        listBoundary,\n        u.withLatestFrom(gridState),\n        u.map(([[, bottom], { offsetBottom }]) => {\n          return { bottom, offsetBottom }\n        })\n      ),\n      stateFlags.listStateListener\n    )\n\n    const endReached = u.streamFromEmitter(\n      u.pipe(\n        u.duc(gridState),\n        u.filter(({ items }) => items.length > 0),\n        u.withLatestFrom(totalCount),\n        u.filter(([{ items }, totalCount]) => items[items.length - 1].index === totalCount - 1),\n        u.map(([, totalCount]) => totalCount - 1),\n        u.distinctUntilChanged()\n      )\n    )\n\n    const startReached = u.streamFromEmitter(\n      u.pipe(\n        u.duc(gridState),\n        u.filter(({ items }) => {\n          return items.length > 0 && items[0].index === 0\n        }),\n        u.mapTo(0),\n        u.distinctUntilChanged()\n      )\n    )\n\n    const rangeChanged = u.streamFromEmitter(\n      u.pipe(\n        u.duc(gridState),\n        u.filter(({ items }) => items.length > 0),\n        u.map(({ items }) => {\n          return {\n            startIndex: items[0].index,\n            endIndex: items[items.length - 1].index,\n          }\n        }),\n        u.distinctUntilChanged(rangeComparator)\n      )\n    )\n\n    u.connect(rangeChanged, scrollSeek.scrollSeekRangeChanged)\n\n    u.connect(\n      u.pipe(\n        scrollToIndex,\n        u.withLatestFrom(viewportDimensions, itemDimensions, totalCount),\n        u.map(([location, viewport, item, totalCount]) => {\n          const normalLocation = normalizeIndexLocation(location)\n          const { align, behavior, offset } = normalLocation\n          let index = normalLocation.index\n\n          index = Math.max(0, index, Math.min(totalCount - 1, index))\n\n          let top = itemTop(viewport, item, index)\n\n          if (align === 'end') {\n            top = Math.round(top - viewport.height + item.height)\n          } else if (align === 'center') {\n            top = Math.round(top - viewport.height / 2 + item.height / 2)\n          }\n\n          if (offset) {\n            top += offset\n          }\n\n          return { top, behavior }\n        })\n      ),\n      scrollTo\n    )\n\n    const totalListHeight = u.statefulStreamFromEmitter(\n      u.pipe(\n        gridState,\n        u.map((gridState) => {\n          return gridState.offsetBottom + gridState.bottom\n        })\n      ),\n      0\n    )\n\n    u.connect(\n      u.pipe(\n        windowViewportRect,\n        u.map((viewportInfo) => ({ width: viewportInfo.visibleWidth, height: viewportInfo.visibleHeight }))\n      ),\n      viewportDimensions\n    )\n\n    return {\n      // input\n      totalCount,\n      viewportDimensions,\n      itemDimensions,\n      scrollTop,\n      overscan,\n      scrollBy,\n      scrollTo,\n      scrollToIndex,\n      smoothScrollTargetReached,\n      windowViewportRect,\n      windowScrollTo,\n      useWindowScroll,\n      windowScrollTop,\n      initialItemCount,\n      ...scrollSeek,\n\n      // output\n      gridState,\n      totalListHeight,\n      ...stateFlags,\n      startReached,\n      endReached,\n      rangeChanged,\n      propsReady,\n    }\n  },\n  u.tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem)\n)\n\nfunction gridLayout(viewport: ElementDimensions, item: ElementDimensions, items: GridItem[]): GridLayout {\n  const { height: itemHeight } = item\n  if (itemHeight === undefined || items.length === 0) {\n    return { top: 0, bottom: 0 }\n  }\n\n  const top = itemTop(viewport, item, items[0].index)\n  const bottom = itemTop(viewport, item, items[items.length - 1].index) + itemHeight\n  return { top, bottom }\n}\n\nfunction itemTop(viewport: ElementDimensions, item: ElementDimensions, index: number) {\n  const perRow = itemsPerRow(viewport.width, item.width)\n  return floor(index / perRow) * item.height\n}\n\nfunction itemsPerRow(viewportWidth: number, itemWidth: number) {\n  return hackFloor(viewportWidth / itemWidth)\n}\n","import { useRef } from 'react'\nimport ResizeObserver from 'resize-observer-polyfill'\n\nexport type CallbackRefParam = HTMLElement | null\n\nexport function useSizeWithElRef(callback: (e: HTMLElement) => void, enabled = true) {\n  const ref = useRef<CallbackRefParam>(null)\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[]) => {\n    const element = entries[0].target as HTMLElement\n    // Revert the RAF below - it causes a blink in the upward scrolling fix\n    // See e2e/chat example\n    // Avoid Resize loop limit exceeded error\n    // https://github.com/edunad/react-virtuoso/commit/581d4558f2994adea375291b76fe59605556c08f\n    // requestAnimationFrame(() => {\n    //\n    // if display: none, the element won't have an offsetParent\n    // measuring it at this mode is not going to work\n    // https://stackoverflow.com/a/21696585/1009797\n    if (element.offsetParent !== null) {\n      callback(element)\n    }\n    // })\n  })\n\n  const callbackRef = (elRef: CallbackRefParam) => {\n    if (elRef && enabled) {\n      observer.observe(elRef)\n      ref.current = elRef\n    } else {\n      if (ref.current) {\n        observer.unobserve(ref.current)\n      }\n      ref.current = null\n    }\n  }\n\n  return { ref, callbackRef }\n}\n\nexport default function useSize(callback: (e: HTMLElement) => void, enabled = true) {\n  return useSizeWithElRef(callback, enabled).callbackRef\n}\n","import { useEffect, useRef, useCallback } from 'react'\nimport { useSizeWithElRef } from './useSize'\nimport { WindowViewportInfo } from '../interfaces'\n\nexport default function useWindowViewportRectRef(callback: (info: WindowViewportInfo) => void) {\n  const viewportInfo = useRef<WindowViewportInfo | null>(null)\n\n  const calculateInfo = useCallback(\n    (element: HTMLElement | null) => {\n      if (element === null) {\n        return\n      }\n      const rect = element.getBoundingClientRect()\n      const visibleHeight = window.innerHeight - Math.max(0, rect.top)\n\n      const visibleWidth = rect.width\n      const offsetTop = rect.top + window.pageYOffset\n      viewportInfo.current = {\n        offsetTop,\n        visibleHeight,\n        visibleWidth,\n      }\n      callback(viewportInfo.current)\n    },\n    [callback]\n  )\n\n  const { callbackRef, ref } = useSizeWithElRef(calculateInfo)\n\n  const windowEH = useCallback(() => {\n    calculateInfo(ref.current)\n  }, [calculateInfo, ref])\n\n  useEffect(() => {\n    window.addEventListener('scroll', windowEH)\n    window.addEventListener('resize', windowEH)\n    return () => {\n      window.removeEventListener('scroll', windowEH)\n      window.removeEventListener('resize', windowEH)\n    }\n  }, [windowEH])\n\n  return callbackRef\n}\n","import { useEffect, useLayoutEffect } from 'react'\n\nconst useIsomorphicLayoutEffect = typeof document !== 'undefined' ? useLayoutEffect : useEffect\n\nexport default useIsomorphicLayoutEffect\n","import { useRef, useCallback, useEffect } from 'react'\nimport * as u from '@virtuoso.dev/urx'\n\nexport type ScrollerRef = Window | HTMLElement | null\n\nexport default function useScrollTop(\n  scrollTopCallback: (scrollTop: number) => void,\n  smoothScrollTargetReached: (yes: true) => void,\n  scrollerElement: any,\n  scrollerRefCallback: (ref: ScrollerRef) => void = u.noop\n) {\n  const scrollerRef = useRef<HTMLElement | null | Window>(null)\n  const scrollTopTarget = useRef<any>(null)\n  const timeoutRef = useRef<any>(null)\n\n  const handler = useCallback(\n    (ev: Event) => {\n      const el = ev.target as HTMLElement\n      const scrollTop =\n        (el as any) === window || (el as any) === document ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop\n      scrollTopCallback(Math.max(scrollTop, 0))\n\n      if (scrollTopTarget.current !== null) {\n        if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === el.scrollHeight - el.offsetHeight) {\n          scrollTopTarget.current = null\n          smoothScrollTargetReached(true)\n          if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current)\n            timeoutRef.current = null\n          }\n        }\n      }\n    },\n    [scrollTopCallback, smoothScrollTargetReached]\n  )\n\n  useEffect(() => {\n    const localRef = scrollerRef.current!\n\n    scrollerRefCallback(scrollerRef.current)\n    handler(({ target: localRef } as unknown) as Event)\n    localRef.addEventListener('scroll', handler, { passive: true })\n\n    return () => {\n      scrollerRefCallback(null)\n      localRef.removeEventListener('scroll', handler)\n    }\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback])\n\n  function scrollToCallback(location: ScrollToOptions) {\n    const scrollerElement = scrollerRef.current\n    if (!scrollerElement) {\n      return\n    }\n\n    const isSmooth = location.behavior === 'smooth'\n\n    let offsetHeight: number\n    let scrollHeight: number\n    let scrollTop: number\n\n    if (scrollerElement === window) {\n      // this is not a mistake\n      scrollHeight = document.documentElement.offsetHeight\n      offsetHeight = window.innerHeight\n      scrollTop = document.documentElement.scrollTop\n    } else {\n      scrollHeight = (scrollerElement as HTMLElement).scrollHeight\n      offsetHeight = (scrollerElement as HTMLElement).offsetHeight\n      scrollTop = (scrollerElement as HTMLElement).scrollTop\n    }\n\n    // avoid system hanging because the DOM never called back\n    // with the scrollTop\n    // scroller is already at this location\n    if (offsetHeight === scrollHeight || location.top === scrollTop) {\n      scrollTopCallback(scrollTop)\n      if (isSmooth) {\n        smoothScrollTargetReached(true)\n      }\n      return\n    }\n\n    const maxScrollTop = scrollHeight - offsetHeight\n    location.top = Math.max(Math.min(maxScrollTop, location.top!), 0)\n\n    if (isSmooth) {\n      scrollTopTarget.current = location.top\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n      }\n\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null\n        scrollTopTarget.current = null\n        smoothScrollTargetReached(true)\n      }, 1000)\n    } else {\n      scrollTopTarget.current = null\n    }\n\n    scrollerElement.scrollTo(location)\n  }\n\n  function scrollByCallback(location: ScrollToOptions) {\n    if (scrollTopTarget.current === null) {\n      scrollerRef.current!.scrollBy(location)\n    }\n  }\n\n  return { scrollerRef, scrollByCallback, scrollToCallback }\n}\n","import * as u from '@virtuoso.dev/urx'\nimport { empty } from './AATree'\nimport { sizeSystem } from './sizeSystem'\nimport { domIOSystem } from './domIOSystem'\nimport { scrollToIndexSystem } from './scrollToIndexSystem'\nimport { propsReadySystem } from './propsReadySystem'\n\nexport const initialTopMostItemIndexSystem = u.system(\n  ([{ sizes, listRefresh }, { scrollTop }, { scrollToIndex }, { didMount }]) => {\n    const scrolledToInitialItem = u.statefulStream(true)\n    const initialTopMostItemIndex = u.statefulStream(0)\n\n    u.connect(\n      u.pipe(\n        didMount,\n        u.withLatestFrom(initialTopMostItemIndex),\n        u.filter(([_, index]) => index !== 0),\n        u.mapTo(false)\n      ),\n      scrolledToInitialItem\n    )\n\n    u.subscribe(\n      u.pipe(\n        listRefresh,\n        u.withLatestFrom(scrolledToInitialItem, sizes),\n        u.filter(([, scrolledToInitialItem, { sizeTree }]) => {\n          return !empty(sizeTree) && !scrolledToInitialItem\n        }),\n        u.withLatestFrom(initialTopMostItemIndex)\n      ),\n      ([, initialTopMostItemIndex]) => {\n        u.handleNext(scrollTop, () => {\n          u.publish(scrolledToInitialItem, true)\n        })\n\n        u.publish(scrollToIndex, initialTopMostItemIndex)\n      }\n    )\n\n    return {\n      scrolledToInitialItem,\n      initialTopMostItemIndex,\n    }\n  },\n  u.tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem),\n  { singleton: true }\n)\n","import * as u from '@virtuoso.dev/urx'\nimport { scrollToIndexSystem } from './scrollToIndexSystem'\nimport { sizeSystem } from './sizeSystem'\nimport { stateFlagsSystem } from './stateFlagsSystem'\nimport { initialTopMostItemIndexSystem } from './initialTopMostItemIndexSystem'\nimport { FollowOutput, FollowOutputScalarType } from './interfaces'\nimport { propsReadySystem } from './propsReadySystem'\n\nfunction normalizeFollowOutput(follow: FollowOutputScalarType): FollowOutputScalarType {\n  if (!follow) {\n    return false\n  }\n  return follow === 'smooth' ? 'smooth' : 'auto'\n}\n\nconst behaviorFromFollowOutput = (follow: FollowOutput, isAtBottom: boolean) => {\n  if (typeof follow === 'function') {\n    return normalizeFollowOutput(follow(isAtBottom))\n  }\n  return isAtBottom && normalizeFollowOutput(follow)\n}\n\nexport const followOutputSystem = u.system(\n  ([\n    { totalCount, listRefresh },\n    { isAtBottom, atBottomState },\n    { scrollToIndex },\n    { scrolledToInitialItem },\n    { propsReady, didMount },\n  ]) => {\n    const followOutput = u.statefulStream<FollowOutput>(false)\n\n    function scrollToBottom(totalCount: number, followOutputBehavior: FollowOutputScalarType) {\n      u.publish(scrollToIndex, {\n        index: totalCount - 1,\n        align: 'end',\n        behavior: followOutputBehavior,\n      })\n    }\n\n    u.subscribe(\n      u.pipe(\n        u.combineLatest(u.duc(totalCount), didMount),\n        u.withLatestFrom(u.duc(followOutput), isAtBottom, scrolledToInitialItem),\n        u.map(([[totalCount, didMount], followOutput, isAtBottom, scrolledToInitialItem]) => {\n          let shouldFollow = didMount && scrolledToInitialItem\n          let followOutputBehavior: FollowOutputScalarType = 'auto'\n\n          if (shouldFollow) {\n            followOutputBehavior = behaviorFromFollowOutput(followOutput, isAtBottom)\n            shouldFollow = shouldFollow && !!followOutputBehavior\n          }\n\n          return { totalCount, shouldFollow, followOutputBehavior }\n        }),\n        u.filter(({ shouldFollow }) => shouldFollow)\n      ),\n      ({ totalCount, followOutputBehavior }) => {\n        u.handleNext(listRefresh, () => {\n          scrollToBottom(totalCount, followOutputBehavior)\n        })\n      }\n    )\n\n    u.subscribe(\n      u.pipe(\n        u.combineLatest(u.duc(followOutput), totalCount, propsReady),\n        u.filter(([follow, , ready]) => follow && ready),\n        u.scan(\n          ({ value }, [, next]) => {\n            return { refreshed: value === next, value: next }\n          },\n          { refreshed: false, value: 0 }\n        ),\n        u.filter(({ refreshed }) => refreshed),\n        u.withLatestFrom(followOutput, totalCount)\n      ),\n      ([, followOutput, totalCount]) => {\n        const cancel = u.handleNext(atBottomState, (state) => {\n          if (followOutput && !state.atBottom && state.notAtBottomBecause === 'SIZE_INCREASED') {\n            scrollToBottom(totalCount, 'auto')\n          }\n        })\n        setTimeout(cancel, 100)\n      }\n    )\n\n    u.subscribe(\n      u.pipe(u.combineLatest(u.duc(followOutput), atBottomState), u.withLatestFrom(totalCount)),\n      ([[followOutput, state], totalCount]) => {\n        if (followOutput && !state.atBottom && state.notAtBottomBecause === 'VIEWPORT_HEIGHT_DECREASING') {\n          scrollToBottom(totalCount, 'auto')\n        }\n      }\n    )\n\n    return { followOutput }\n  },\n  u.tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem)\n)\n","import {\n  combineLatest,\n  connect,\n  distinctUntilChanged,\n  system,\n  filter,\n  map,\n  pipe,\n  prop,\n  stream,\n  streamFromEmitter,\n  tup,\n} from '@virtuoso.dev/urx'\nimport { findMaxKeyValue } from './AATree'\nimport { domIOSystem } from './domIOSystem'\nimport { sizeSystem, hasGroups } from './sizeSystem'\nexport interface GroupIndexesAndCount {\n  totalCount: number\n  groupIndices: number[]\n}\n\nexport function groupCountsToIndicesAndCount(counts: number[]) {\n  return counts.reduce(\n    (acc, groupCount) => {\n      acc.groupIndices.push(acc.totalCount)\n      acc.totalCount += groupCount + 1\n      return acc\n    },\n    {\n      totalCount: 0,\n      groupIndices: [],\n    } as GroupIndexesAndCount\n  )\n}\n\nexport const groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }]) => {\n  const groupCounts = stream<number[]>()\n  const topItemsIndexes = stream<[number]>()\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)))\n  connect(pipe(groupIndicesAndCount, map(prop('totalCount'))), totalCount)\n  connect(pipe(groupIndicesAndCount, map(prop('groupIndices'))), groupIndices)\n\n  connect(\n    pipe(\n      combineLatest(scrollTop, sizes, headerHeight),\n      filter(([_, sizes]) => hasGroups(sizes)),\n      map(([scrollTop, state, headerHeight]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop - headerHeight, 0), 'v')[0]),\n      distinctUntilChanged(),\n      map((index) => [index])\n    ),\n    topItemsIndexes\n  )\n\n  return { groupCounts, topItemsIndexes }\n}, tup(sizeSystem, domIOSystem))\n","import * as u from '@virtuoso.dev/urx'\nimport { empty, findMaxKeyValue, Range, rangesWithin } from './AATree'\nimport { domIOSystem } from './domIOSystem'\nimport { groupedListSystem } from './groupedListSystem'\nimport { initialTopMostItemIndexSystem } from './initialTopMostItemIndexSystem'\nimport { Item, ListItem, ListRange } from './interfaces'\nimport { propsReadySystem } from './propsReadySystem'\nimport { scrollToIndexSystem } from './scrollToIndexSystem'\nimport { sizeRangeSystem } from './sizeRangeSystem'\nimport { Data, originalIndexFromItemIndex, SizeState, sizeSystem, hasGroups, rangesWithinOffsets } from './sizeSystem'\nimport { stateFlagsSystem } from './stateFlagsSystem'\nimport { rangeComparator, tupleComparator } from './comparators'\n\nexport type ListItems = ListItem<unknown>[]\nexport interface TopListState {\n  items: ListItems\n  listHeight: number\n}\n\nexport interface ListState {\n  items: ListItems\n  topItems: ListItems\n  topListHeight: number\n  offsetTop: number\n  offsetBottom: number\n  top: number\n  bottom: number\n  totalCount: number\n}\n\nfunction probeItemSet(index: number, sizes: SizeState, data: Data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes)\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0]\n\n    return [\n      { index: groupIndex, size: 0, offset: 0 },\n      { index: itemIndex, size: 0, offset: 0, data: data && data[0] },\n    ]\n  }\n  return [{ index, size: 0, offset: 0, data: data && data[0] }]\n}\n\nconst EMPTY_LIST_STATE: ListState = {\n  items: [] as ListItems,\n  topItems: [] as ListItems,\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n}\n\nfunction transposeItems(items: Item<any>[], sizes: SizeState, firstItemIndex: number): ListItems {\n  if (items.length === 0) {\n    return []\n  }\n\n  if (!hasGroups(sizes)) {\n    return items.map((item) => ({ ...item, index: item.index + firstItemIndex, originalIndex: item.index }))\n  }\n\n  const startIndex = items[0].index\n  const endIndex = items[items.length - 1].index\n\n  const transposedItems = [] as ListItems\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex)\n  let currentRange: Range<number> | undefined = undefined\n  let currentGroupIndex = 0\n\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift()!\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start)\n    }\n\n    let transposedItem: { type: 'group'; index: number } | { index: number; groupIndex: number }\n\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: 'group' as const,\n        index: currentGroupIndex,\n      }\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex,\n      }\n    }\n\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data,\n    })\n  }\n\n  return transposedItems\n}\n\nexport function buildListState(\n  items: Item<any>[],\n  topItems: Item<any>[],\n  totalCount: number,\n  sizes: SizeState,\n  firstItemIndex: number\n): ListState {\n  const { lastSize, lastOffset, lastIndex } = sizes\n  let offsetTop = 0\n  let bottom = 0\n\n  if (items.length > 0) {\n    offsetTop = items[0].offset\n    const lastItem = items[items.length - 1]\n    bottom = lastItem.offset + lastItem.size\n  }\n\n  const total = lastOffset + (totalCount - lastIndex) * lastSize\n  const top = offsetTop\n  const offsetBottom = total - bottom\n\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n  }\n}\n\nexport const listStateSystem = u.system(\n  ([\n    { statefulScrollTop, headerHeight },\n    { sizes, totalCount, data, firstItemIndex },\n    groupedListSystem,\n    { visibleRange, listBoundary, topListHeight: rangeTopListHeight },\n    { scrolledToInitialItem, initialTopMostItemIndex },\n    { topListHeight },\n    stateFlags,\n    { didMount },\n  ]) => {\n    const topItemsIndexes = u.statefulStream<Array<number>>([])\n    const itemsRendered = u.stream<ListItems>()\n\n    u.connect(groupedListSystem.topItemsIndexes, topItemsIndexes)\n\n    const listState = u.statefulStreamFromEmitter(\n      u.pipe(\n        u.combineLatest(\n          didMount,\n          u.duc(visibleRange),\n          u.duc(totalCount),\n          u.duc(sizes),\n          u.duc(initialTopMostItemIndex),\n          scrolledToInitialItem,\n          u.duc(topItemsIndexes),\n          u.duc(firstItemIndex),\n          data\n        ),\n        u.filter(([mount]) => mount),\n        u.map(\n          ([\n            ,\n            [startOffset, endOffset],\n            totalCount,\n            sizes,\n            initialTopMostItemIndex,\n            scrolledToInitialItem,\n            topItemsIndexes,\n            firstItemIndex,\n            data,\n          ]) => {\n            const sizesValue = sizes\n            const { sizeTree, offsetTree } = sizesValue\n\n            if (totalCount === 0 || (startOffset === 0 && endOffset === 0)) {\n              return EMPTY_LIST_STATE\n            }\n\n            if (empty(sizeTree)) {\n              return buildListState(probeItemSet(initialTopMostItemIndex, sizesValue, data), [], totalCount, sizesValue, firstItemIndex)\n            }\n\n            const topItems = [] as Item<any>[]\n\n            if (topItemsIndexes.length > 0) {\n              const startIndex = topItemsIndexes[0]\n              const endIndex = topItemsIndexes[topItemsIndexes.length - 1]\n              let offset = 0\n              for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n                const size = range.value\n                const rangeStartIndex = Math.max(range.start, startIndex)\n                const rangeEndIndex = Math.min(range.end, endIndex)\n                for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n                  topItems.push({ index: i, size, offset: offset, data: data && data[i] })\n                  offset += size\n                }\n              }\n            }\n\n            // If the list hasn't scrolled to the initial item because the initial item was set,\n            // render empty list.\n            //\n            // This is a condition to be evaluated past the probe check, do not merge\n            // with the totalCount check above\n            if (!scrolledToInitialItem) {\n              return buildListState([], topItems, totalCount, sizesValue, firstItemIndex)\n            }\n\n            // pull a fresh top group, avoids a bug where\n            // scrolling up too fast causes stack overflow\n            if (hasGroups(sizesValue)) {\n              const scrollTop = Math.max(u.getValue(statefulScrollTop) - u.getValue(headerHeight), 0)\n              topItemsIndexes = [findMaxKeyValue(sizesValue.groupOffsetTree, scrollTop, 'v')[0]]\n            }\n\n            const minStartIndex = topItemsIndexes.length > 0 ? topItemsIndexes[topItemsIndexes.length - 1] + 1 : 0\n\n            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex)\n            const maxIndex = totalCount - 1\n\n            const items = u.tap([] as Item<any>[], (result) => {\n              for (const range of offsetPointRanges) {\n                const point = range.value\n                let offset = point.offset\n                let rangeStartIndex = range.start\n                const size = point.size\n\n                if (point.offset < startOffset) {\n                  rangeStartIndex += Math.floor((startOffset - point.offset) / size)\n                  offset += (rangeStartIndex - range.start) * size\n                }\n\n                if (rangeStartIndex < minStartIndex) {\n                  offset += (minStartIndex - rangeStartIndex) * size\n                  rangeStartIndex = minStartIndex\n                }\n\n                const endIndex = Math.min(range.end, maxIndex)\n\n                for (let i = rangeStartIndex; i <= endIndex; i++) {\n                  if (offset >= endOffset) {\n                    break\n                  }\n\n                  result.push({ index: i, size, offset: offset, data: data && data[i] })\n                  offset += size\n                }\n              }\n            })\n\n            return buildListState(items, topItems, totalCount, sizesValue, firstItemIndex)\n          }\n        ),\n        u.distinctUntilChanged()\n      ),\n      EMPTY_LIST_STATE\n    )\n\n    u.connect(\n      u.pipe(\n        data,\n        u.filter((data) => data !== undefined),\n        u.map((data) => data!.length)\n      ),\n      totalCount\n    )\n\n    u.connect(u.pipe(listState, u.map(u.prop('topListHeight'))), topListHeight)\n    u.connect(topListHeight, rangeTopListHeight)\n    u.connect(listState, stateFlags.listStateListener)\n\n    u.connect(\n      u.pipe(\n        listState,\n        u.map((state) => [state.top, state.bottom])\n      ),\n      listBoundary\n    )\n\n    u.connect(\n      u.pipe(\n        listState,\n        u.map((state) => state.items)\n      ),\n      itemsRendered\n    )\n\n    const endReached = u.streamFromEmitter(\n      u.pipe(\n        listState,\n        u.filter(({ items }) => items.length > 0),\n        u.withLatestFrom(totalCount, data),\n        u.filter(([{ items }, totalCount]) => items[items.length - 1].originalIndex === totalCount - 1),\n        u.map(([, totalCount, data]) => [totalCount - 1, data] as [number, unknown[]]),\n        u.distinctUntilChanged(tupleComparator),\n        u.map(([count]) => count as number)\n      )\n    )\n\n    const startReached = u.streamFromEmitter(\n      u.pipe(\n        listState,\n        u.throttleTime(200),\n        u.filter(({ items, topItems }) => {\n          return items.length > 0 && items[0].originalIndex === topItems.length\n        }),\n        u.map(({ items }) => items[0].index),\n        u.distinctUntilChanged()\n      )\n    )\n\n    const rangeChanged = u.streamFromEmitter(\n      u.pipe(\n        listState,\n        u.filter(({ items }) => items.length > 0),\n        u.map(({ items }) => {\n          return {\n            startIndex: items[0].index,\n            endIndex: items[items.length - 1].index,\n          } as ListRange\n        }),\n        u.distinctUntilChanged(rangeComparator)\n      )\n    )\n\n    return { listState, topItemsIndexes, endReached, startReached, rangeChanged, itemsRendered, ...stateFlags }\n  },\n  u.tup(\n    domIOSystem,\n    sizeSystem,\n    groupedListSystem,\n    sizeRangeSystem,\n    initialTopMostItemIndexSystem,\n    scrollToIndexSystem,\n    stateFlagsSystem,\n    propsReadySystem\n  ),\n  { singleton: true }\n)\n","export function simpleMemoize<T extends () => any>(func: T): T {\n  let called = false\n  let result: unknown\n\n  return (() => {\n    if (!called) {\n      called = true\n      result = func()\n    }\n    return result\n  }) as T\n}\n","import * as u from '@virtuoso.dev/urx'\nimport { listStateSystem, buildListState } from './listStateSystem'\nimport { sizeSystem } from './sizeSystem'\nimport { propsReadySystem } from './propsReadySystem'\n\nexport const initialItemCountSystem = u.system(\n  ([{ sizes, firstItemIndex, data }, { listState }, { didMount }]) => {\n    const initialItemCount = u.statefulStream(0)\n\n    u.connect(\n      u.pipe(\n        didMount,\n        u.withLatestFrom(initialItemCount),\n        u.filter(([, count]) => count !== 0),\n        u.withLatestFrom(sizes, firstItemIndex, data),\n        u.map(([[, count], sizes, firstItemIndex, data = []]) => {\n          let includedGroupsCount = 0\n          if (sizes.groupIndices.length > 0) {\n            for (const index of sizes.groupIndices) {\n              if (index - includedGroupsCount >= count) {\n                break\n              }\n              includedGroupsCount++\n            }\n          }\n          const adjustedCount = count + includedGroupsCount\n          const items = Array.from({ length: adjustedCount }).map((_, index) => ({ index, size: 0, offset: 0, data: data[index] }))\n          return buildListState(items, [], adjustedCount, sizes, firstItemIndex)\n        })\n      ),\n      listState\n    )\n\n    return { initialItemCount }\n  },\n  u.tup(sizeSystem, listStateSystem, propsReadySystem),\n  { singleton: true }\n)\n","import { connect, system, map, pipe, statefulStream, tup, filter } from '@virtuoso.dev/urx'\nimport { listStateSystem } from './listStateSystem'\n\nexport const topItemCountSystem = system(([{ topItemsIndexes }]) => {\n  const topItemCount = statefulStream(0)\n\n  connect(\n    pipe(\n      topItemCount,\n      filter((length) => length > 0),\n      map((length) => Array.from({ length }).map((_, index) => index))\n    ),\n    topItemsIndexes\n  )\n  return { topItemCount }\n}, tup(listStateSystem))\n","import * as u from '@virtuoso.dev/urx'\nimport { listStateSystem } from './listStateSystem'\nimport { domIOSystem } from './domIOSystem'\n\nexport const totalListHeightSystem = u.system(\n  ([{ footerHeight, headerHeight }, { listState }]) => {\n    const totalListHeightChanged = u.stream<number>()\n    const totalListHeight = u.statefulStreamFromEmitter(\n      u.pipe(\n        u.combineLatest(footerHeight, headerHeight, listState),\n        u.map(([footerHeight, headerHeight, listState]) => {\n          return footerHeight + headerHeight + listState.offsetBottom + listState.bottom\n        })\n      ),\n      0\n    )\n\n    u.connect(u.duc(totalListHeight), totalListHeightChanged)\n\n    return { totalListHeight, totalListHeightChanged }\n  },\n  u.tup(domIOSystem, listStateSystem),\n  { singleton: true }\n)\n","import * as u from '@virtuoso.dev/urx'\nimport { UP, domIOSystem } from './domIOSystem'\nimport { listStateSystem } from './listStateSystem'\nimport { sizeSystem } from './sizeSystem'\nimport { stateFlagsSystem } from './stateFlagsSystem'\nimport { ListItem } from './interfaces'\n\n/**\n * Fixes upward scrolling by calculating and compensation from changed item heights, using scrollBy.\n */\nexport const upwardScrollFixSystem = u.system(\n  ([\n    { scrollBy, scrollTop, scrollDirection, deviation, scrollingInProgress },\n    { isScrolling },\n    { listState },\n    { beforeUnshiftWith, sizes },\n  ]) => {\n    const deviationOffset = u.streamFromEmitter(\n      u.pipe(\n        listState,\n        u.withLatestFrom(scrollTop, scrollDirection, scrollingInProgress),\n        u.filter(([, scrollTop, scrollDirection, scrollingInProgress]) => {\n          return !scrollingInProgress && scrollTop !== 0 && scrollDirection === UP\n        }),\n        u.map(([state]) => state),\n        u.scan(\n          ([, prevItems], { items }) => {\n            let newDev = 0\n            if (prevItems.length > 0 && items.length > 0) {\n              const firstItemIndex = items[0].originalIndex\n              const prevFirstItemIndex = prevItems[0].originalIndex\n              const atStart = firstItemIndex === 0 && prevFirstItemIndex === 0\n\n              if (!atStart) {\n                // Handles an item taller than the viewport\n                if (firstItemIndex === prevFirstItemIndex) {\n                  newDev = items[0].size - prevItems[0].size\n                } else {\n                  for (let index = items.length - 1; index >= 0; index--) {\n                    const item = items[index]\n\n                    const prevItem = prevItems.find((pItem) => pItem.originalIndex === item.originalIndex)\n\n                    if (!prevItem) {\n                      continue\n                    }\n\n                    if (item.offset !== prevItem.offset) {\n                      newDev = item.offset - prevItem.offset\n                      break\n                    }\n                  }\n                }\n              }\n            }\n\n            return [newDev, items] as [number, ListItem<any>[]]\n          },\n          [0, []] as [number, ListItem<any>[]]\n        ),\n        u.filter(([amount]) => amount !== 0),\n        u.map(([amount]) => amount)\n      )\n    )\n\n    u.connect(\n      u.pipe(\n        deviationOffset,\n        u.withLatestFrom(deviation),\n        u.map(([amount, deviation]) => deviation - amount)\n      ),\n      deviation\n    )\n\n    // when the browser stops scrolling,\n    // restore the position and reset the glitching\n    u.subscribe(\n      u.pipe(\n        u.combineLatest(u.statefulStreamFromEmitter(isScrolling, false), deviation),\n        u.filter(([is, deviation]) => !is && deviation !== 0),\n        u.map(([_, deviation]) => deviation),\n        u.throttleTime(1)\n      ),\n      (offset) => {\n        if (offset > 0) {\n          u.publish(scrollBy, { top: -offset, behavior: 'auto' })\n          u.publish(deviation, 0)\n        } else {\n          u.publish(deviation, 0)\n          u.publish(scrollBy, { top: -offset, behavior: 'auto' })\n        }\n      }\n    )\n\n    u.connect(\n      u.pipe(\n        beforeUnshiftWith,\n        u.withLatestFrom(sizes),\n        u.map(([offset, { lastSize }]) => offset * lastSize)\n      ),\n      deviationOffset\n    )\n\n    return { deviation }\n  },\n  u.tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem)\n)\n","import * as u from '@virtuoso.dev/urx'\nimport { totalListHeightSystem } from './totalListHeightSystem'\nimport { propsReadySystem } from './propsReadySystem'\nimport { domIOSystem } from './domIOSystem'\n\nexport const initialScrollTopSystem = u.system(\n  ([{ totalListHeight }, { didMount }, { scrollTo }]) => {\n    const initialScrollTop = u.statefulStream(0)\n\n    u.subscribe(\n      u.pipe(\n        didMount,\n        u.withLatestFrom(initialScrollTop),\n        u.filter(([, offset]) => offset !== 0),\n        u.map(([, offset]) => ({ top: offset }))\n      ),\n      (location) => {\n        u.handleNext(\n          u.pipe(\n            totalListHeight,\n            u.filter((val) => val !== 0)\n          ),\n          () => {\n            setTimeout(() => {\n              u.publish(scrollTo, location)\n            })\n          }\n        )\n      }\n    )\n\n    return {\n      initialScrollTop,\n    }\n  },\n  u.tup(totalListHeightSystem, propsReadySystem, domIOSystem),\n  { singleton: true }\n)\n","import * as u from '@virtuoso.dev/urx'\nimport { totalListHeightSystem } from './totalListHeightSystem'\nimport { domIOSystem } from './domIOSystem'\n\nexport const alignToBottomSystem = u.system(\n  ([{ viewportHeight }, { totalListHeight }]) => {\n    const alignToBottom = u.statefulStream(false)\n\n    const paddingTopAddition = u.statefulStreamFromEmitter(\n      u.pipe(\n        u.combineLatest(alignToBottom, viewportHeight, totalListHeight),\n        u.filter(([enabled]) => enabled),\n        u.map(([, viewportHeight, totalListHeight]) => {\n          return Math.max(0, viewportHeight - totalListHeight)\n        }),\n        u.distinctUntilChanged()\n      ),\n      0\n    )\n\n    return { alignToBottom, paddingTopAddition }\n  },\n  u.tup(domIOSystem, totalListHeightSystem),\n  { singleton: true }\n)\n","import * as u from '@virtuoso.dev/urx'\nimport { domIOSystem } from './domIOSystem'\nimport { followOutputSystem } from './followOutputSystem'\nimport { groupedListSystem } from './groupedListSystem'\nimport { initialItemCountSystem } from './initialItemCountSystem'\nimport { initialTopMostItemIndexSystem } from './initialTopMostItemIndexSystem'\nimport { listStateSystem } from './listStateSystem'\nimport { propsReadySystem } from './propsReadySystem'\nimport { scrollSeekSystem } from './scrollSeekSystem'\nimport { scrollToIndexSystem } from './scrollToIndexSystem'\nimport { sizeRangeSystem } from './sizeRangeSystem'\nimport { sizeSystem } from './sizeSystem'\nimport { topItemCountSystem } from './topItemCountSystem'\nimport { totalListHeightSystem } from './totalListHeightSystem'\nimport { upwardScrollFixSystem } from './upwardScrollFixSystem'\nimport { initialScrollTopSystem } from './initialScrollTopSystem'\nimport { alignToBottomSystem } from './alignToBottomSystem'\nimport { windowScrollerSystem } from './windowScrollerSystem'\n\n// workaround the growing list of systems below\n// fix this with 4.1 recursive conditional types\nconst featureGroup1System = u.system(\n  ([sizeRange, initialItemCount, propsReady, scrollSeek, totalListHeight, initialScrollTopSystem, alignToBottom, windowScroller]) => {\n    return {\n      ...sizeRange,\n      ...initialItemCount,\n      ...propsReady,\n      ...scrollSeek,\n      ...totalListHeight,\n      ...initialScrollTopSystem,\n      ...alignToBottom,\n      ...windowScroller,\n    }\n  },\n  u.tup(\n    sizeRangeSystem,\n    initialItemCountSystem,\n    propsReadySystem,\n    scrollSeekSystem,\n    totalListHeightSystem,\n    initialScrollTopSystem,\n    alignToBottomSystem,\n    windowScrollerSystem\n  )\n)\n\nexport const listSystem = u.system(\n  ([\n    { totalCount, sizeRanges, fixedItemSize, defaultItemSize, trackItemSizes, data, firstItemIndex, groupIndices },\n    { initialTopMostItemIndex, scrolledToInitialItem },\n    domIO,\n    followOutput,\n    { listState, topItemsIndexes, ...flags },\n    { scrollToIndex },\n    _,\n    { topItemCount },\n    { groupCounts },\n    featureGroup1,\n  ]) => {\n    u.connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged)\n    u.connect(u.pipe(featureGroup1.windowViewportRect, u.map(u.prop('visibleHeight'))), domIO.viewportHeight)\n\n    return {\n      // input\n      totalCount,\n      data,\n      firstItemIndex,\n      sizeRanges,\n      initialTopMostItemIndex,\n      scrolledToInitialItem,\n      topItemsIndexes,\n      topItemCount,\n      groupCounts,\n      fixedItemHeight: fixedItemSize,\n      defaultItemHeight: defaultItemSize,\n      ...followOutput,\n\n      // output\n      listState,\n      scrollToIndex,\n      trackItemSizes,\n      groupIndices,\n\n      // exported from stateFlagsSystem\n      ...flags,\n      // the bag of IO from featureGroup1System\n      ...featureGroup1,\n      ...domIO,\n    }\n  },\n  u.tup(\n    sizeSystem,\n    initialTopMostItemIndexSystem,\n    domIOSystem,\n    followOutputSystem,\n    listStateSystem,\n    scrollToIndexSystem,\n    upwardScrollFixSystem,\n    topItemCountSystem,\n    groupedListSystem,\n    featureGroup1System\n  )\n)\n","import { simpleMemoize } from './simpleMemoize'\n\nconst WEBKIT_STICKY = '-webkit-sticky'\nconst STICKY = 'sticky'\n\nexport const positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === 'undefined') {\n    return STICKY\n  }\n  const node = document.createElement('div')\n  node.style.position = WEBKIT_STICKY\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY\n})\n","import { RefHandle, systemToComponent } from '@virtuoso.dev/react-urx'\nimport {\n  compose,\n  connect,\n  getValue,\n  map,\n  pipe,\n  prop,\n  publish,\n  statefulStream,\n  stream,\n  Stream,\n  subscribe,\n  system,\n  tup,\n  withLatestFrom,\n  statefulStreamFromEmitter,\n  distinctUntilChanged,\n  noop,\n} from '@virtuoso.dev/urx'\nimport * as React from 'react'\nimport { createElement, CSSProperties, FC } from 'react'\nimport useIsomorphicLayoutEffect from './hooks/useIsomorphicLayoutEffect'\nimport useChangedChildSizes from './hooks/useChangedChildSizes'\nimport useScrollTop from './hooks/useScrollTop'\nimport useSize from './hooks/useSize'\nimport { Components, ComputeItemKey, GroupContent, GroupItemContent, ItemContent, ListRootProps } from './interfaces'\nimport { listSystem } from './listSystem'\nimport { positionStickyCssValue } from './utils/positionStickyCssValue'\nimport useWindowViewportRectRef from './hooks/useWindowViewportRect'\n\nexport function identity<T>(value: T) {\n  return value\n}\n\nconst listComponentPropsSystem = system(() => {\n  const itemContent = statefulStream<ItemContent<any> | GroupItemContent<any>>((index: number) => `Item ${index}`)\n  const groupContent = statefulStream<GroupContent>((index: number) => `Group ${index}`)\n  const components = statefulStream<Components>({})\n  const computeItemKey = statefulStream<ComputeItemKey>(identity)\n  const headerFooterTag = statefulStream('div')\n  const scrollerRef = statefulStream<(ref: HTMLElement | Window | null) => void>(noop)\n\n  const distinctProp = <K extends keyof Components>(propName: K, defaultValue: Components[K] | null | 'div' = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components) => components[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    )\n  }\n\n  return {\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp('Footer'),\n    HeaderComponent: distinctProp('Header'),\n    TopItemListComponent: distinctProp('TopItemList'),\n    ListComponent: distinctProp('List', 'div'),\n    ItemComponent: distinctProp('Item', 'div'),\n    GroupComponent: distinctProp('Group', 'div'),\n    ScrollerComponent: distinctProp('Scroller', 'div'),\n    EmptyPlaceholder: distinctProp('EmptyPlaceholder'),\n    ScrollSeekPlaceholder: distinctProp('ScrollSeekPlaceholder'),\n  }\n})\n\nexport function addDeprecatedAlias<T>(prop: Stream<T>, message: string) {\n  const alias = stream<T>()\n  subscribe(alias, () =>\n    console.warn(`react-virtuoso: You are using a deprecated property. ${message}`, 'color: red;', 'color: inherit;', 'color: blue;')\n  )\n  connect(alias, prop)\n  return alias\n}\n\nconst combinedSystem = system(([listSystem, propsSystem]) => {\n  const deprecatedProps = {\n    item: addDeprecatedAlias(propsSystem.itemContent, 'Rename the %citem%c prop to %citemContent.'),\n    group: addDeprecatedAlias(propsSystem.groupContent, 'Rename the %cgroup%c prop to %cgroupContent.'),\n    topItems: addDeprecatedAlias(listSystem.topItemCount, 'Rename the %ctopItems%c prop to %ctopItemCount.'),\n    itemHeight: addDeprecatedAlias(listSystem.fixedItemHeight, 'Rename the %citemHeight%c prop to %cfixedItemHeight.'),\n    scrollingStateChange: addDeprecatedAlias(listSystem.isScrolling, 'Rename the %cscrollingStateChange%c prop to %cisScrolling.'),\n    adjustForPrependedItems: stream<any>(),\n    maxHeightCacheSize: stream<any>(),\n    footer: stream<any>(),\n    header: stream<any>(),\n    HeaderContainer: stream<any>(),\n    FooterContainer: stream<any>(),\n    ItemContainer: stream<any>(),\n    ScrollContainer: stream<any>(),\n    GroupContainer: stream<any>(),\n    ListContainer: stream<any>(),\n    emptyComponent: stream<any>(),\n    scrollSeek: stream<any>(),\n  }\n\n  subscribe(deprecatedProps.adjustForPrependedItems, () => {\n    console.warn(\n      `react-virtuoso: adjustForPrependedItems is no longer supported. Use the firstItemIndex property instead - https://virtuoso.dev/prepend-items.`,\n      'color: red;',\n      'color: inherit;',\n      'color: blue;'\n    )\n  })\n\n  subscribe(deprecatedProps.maxHeightCacheSize, () => {\n    console.warn(`react-virtuoso: maxHeightCacheSize is no longer necessary. Setting it has no effect - remove it from your code.`)\n  })\n\n  subscribe(deprecatedProps.HeaderContainer, () => {\n    console.warn(\n      `react-virtuoso: HeaderContainer is deprecated. Use headerFooterTag if you want to change the wrapper of the header component and pass components.Header to change its contents.`\n    )\n  })\n\n  subscribe(deprecatedProps.FooterContainer, () => {\n    console.warn(\n      `react-virtuoso: FooterContainer is deprecated. Use headerFooterTag if you want to change the wrapper of the footer component and pass components.Footer to change its contents.`\n    )\n  })\n\n  function deprecateComponentProp(stream: Stream<any>, componentName: string, propName: string) {\n    connect(\n      pipe(\n        stream,\n        withLatestFrom(propsSystem.components),\n        map(([comp, components]) => {\n          console.warn(`react-virtuoso: ${propName} property is deprecated. Pass components.${componentName} instead.`)\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          return { ...components, [componentName]: comp }\n        })\n      ),\n      propsSystem.components\n    )\n  }\n\n  subscribe(deprecatedProps.scrollSeek, ({ placeholder, ...config }) => {\n    console.warn(\n      `react-virtuoso: scrollSeek property is deprecated. Pass scrollSeekConfiguration and specify the placeholder in components.ScrollSeekPlaceholder instead.`\n    )\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    publish(propsSystem.components, { ...getValue(propsSystem.components), ScrollSeekPlaceholder: placeholder })\n    publish(listSystem.scrollSeekConfiguration, config)\n  })\n\n  deprecateComponentProp(deprecatedProps.footer, 'Footer', 'footer')\n  deprecateComponentProp(deprecatedProps.header, 'Header', 'header')\n  deprecateComponentProp(deprecatedProps.ItemContainer, 'Item', 'ItemContainer')\n  deprecateComponentProp(deprecatedProps.ListContainer, 'List', 'ListContainer')\n  deprecateComponentProp(deprecatedProps.ScrollContainer, 'Scroller', 'ScrollContainer')\n  deprecateComponentProp(deprecatedProps.emptyComponent, 'EmptyPlaceholder', 'emptyComponent')\n  deprecateComponentProp(deprecatedProps.GroupContainer, 'Group', 'GroupContainer')\n\n  return { ...listSystem, ...propsSystem, ...deprecatedProps }\n}, tup(listSystem, listComponentPropsSystem))\n\nconst DefaultScrollSeekPlaceholder = ({ height }: { height: number }) => <div style={{ height }}></div>\n\nconst GROUP_STYLE = { position: positionStickyCssValue(), zIndex: 1 }\n\nexport const Items = React.memo(function VirtuosoItems({ showTopList = false }: { showTopList?: boolean }) {\n  const listState = useEmitterValue('listState')\n  const deviation = useEmitterValue('deviation')\n  const sizeRanges = usePublisher('sizeRanges')\n  const itemContent = useEmitterValue('itemContent')\n  const groupContent = useEmitterValue('groupContent')\n  const trackItemSizes = useEmitterValue('trackItemSizes')\n\n  const ref = useChangedChildSizes(sizeRanges, trackItemSizes)\n  const EmptyPlaceholder = useEmitterValue('EmptyPlaceholder')\n  const ScrollSeekPlaceholder = useEmitterValue('ScrollSeekPlaceholder') || DefaultScrollSeekPlaceholder\n  const ListComponent = useEmitterValue('ListComponent')!\n  const ItemComponent = useEmitterValue('ItemComponent')!\n  const GroupComponent = useEmitterValue('GroupComponent')!\n  const computeItemKey = useEmitterValue('computeItemKey')\n  const isSeeking = useEmitterValue('isSeeking')\n  const hasGroups = useEmitterValue('groupIndices').length > 0\n  const paddingTopAddition = useEmitterValue('paddingTopAddition')\n  const scrolledToInitialItem = useEmitterValue('scrolledToInitialItem')\n\n  // const calculatedHeight = listState.offsetBottom + listState.bottom\n  const containerStyle: CSSProperties = showTopList\n    ? {}\n    : {\n        boxSizing: 'border-box',\n        paddingTop: listState.offsetTop + paddingTopAddition,\n        paddingBottom: listState.offsetBottom,\n        marginTop: deviation,\n        // height: calculatedHeight,\n      }\n\n  if (!showTopList && listState.items.length === 0 && EmptyPlaceholder && scrolledToInitialItem) {\n    return createElement(EmptyPlaceholder)\n  }\n\n  return createElement(\n    ListComponent,\n    { ref, style: containerStyle },\n    (showTopList ? listState.topItems : listState.items).map((item) => {\n      const index = item.originalIndex!\n      const key = computeItemKey(index)\n\n      if (isSeeking) {\n        return createElement(ScrollSeekPlaceholder, { key, index: item.index, height: item.size })\n      }\n\n      if (item.type === 'group') {\n        return createElement(\n          GroupComponent,\n          {\n            key,\n            'data-index': index,\n            'data-known-size': item.size,\n            'data-item-index': item.index,\n            style: GROUP_STYLE,\n          } as any,\n          groupContent(item.index)\n        )\n      } else {\n        return createElement(\n          ItemComponent,\n          {\n            key,\n            'data-index': index,\n            'data-known-size': item.size,\n            'data-item-index': item.index,\n            'data-item-group-index': item.groupIndex,\n          } as any,\n          hasGroups\n            ? (itemContent as GroupItemContent<any>)(item.index, item.groupIndex!, item.data)\n            : (itemContent as ItemContent<any>)(item.index, item.data)\n        )\n      }\n    })\n  )\n})\n\nexport const scrollerStyle: CSSProperties = {\n  height: '100%',\n  outline: 'none',\n  overflowY: 'auto',\n  position: 'relative',\n  WebkitOverflowScrolling: 'touch',\n}\n\nexport const viewportStyle: CSSProperties = {\n  width: '100%',\n  height: '100%',\n  position: 'absolute',\n  top: 0,\n}\n\nconst topItemListStyle: CSSProperties = {\n  width: '100%',\n  position: positionStickyCssValue(),\n  top: 0,\n}\n\nconst Header: FC = React.memo(function VirtuosoHeader() {\n  const Header = useEmitterValue('HeaderComponent')\n  const headerHeight = usePublisher('headerHeight')\n  const headerFooterTag = useEmitterValue('headerFooterTag')\n  const ref = useSize((el) => headerHeight(el.offsetHeight))\n  return Header ? createElement(headerFooterTag, { ref }, createElement(Header)) : null\n})\n\nconst Footer: FC = React.memo(function VirtuosoFooter() {\n  const Footer = useEmitterValue('FooterComponent')\n  const footerHeight = usePublisher('footerHeight')\n  const headerFooterTag = useEmitterValue('headerFooterTag')\n  const ref = useSize((el) => footerHeight(el.offsetHeight))\n  return Footer ? createElement(headerFooterTag, { ref }, createElement(Footer)) : null\n})\n\nexport interface Hooks {\n  usePublisher: typeof usePublisher\n  useEmitterValue: typeof useEmitterValue\n  useEmitter: typeof useEmitter\n}\n\nexport function buildScroller({ usePublisher, useEmitter, useEmitterValue }: Hooks) {\n  const Scroller: Components['Scroller'] = React.memo(function VirtuosoScroller({ style, children, ...props }) {\n    const scrollTopCallback = usePublisher('scrollTop')\n    const ScrollerComponent = useEmitterValue('ScrollerComponent')!\n    const smoothScrollTargetReached = usePublisher('smoothScrollTargetReached')\n    const scrollerRefCallback = useEmitterValue('scrollerRef')\n\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollTopCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      scrollerRefCallback\n    )\n\n    useEmitter('scrollTo', scrollToCallback)\n    useEmitter('scrollBy', scrollByCallback)\n    return createElement(\n      ScrollerComponent,\n      {\n        ref: scrollerRef as React.MutableRefObject<HTMLDivElement | null>,\n        style: { ...scrollerStyle, ...style },\n        tabIndex: 0,\n        ...props,\n      },\n      children\n    )\n  })\n  return Scroller\n}\n\nexport function buildWindowScroller({ usePublisher, useEmitter, useEmitterValue }: Hooks) {\n  const Scroller: Components['Scroller'] = React.memo(function VirtuosoWindowScroller({ style, children, ...props }) {\n    const scrollTopCallback = usePublisher('windowScrollTop')\n    const ScrollerComponent = useEmitterValue('ScrollerComponent')!\n    const smoothScrollTargetReached = usePublisher('smoothScrollTargetReached')\n    const totalListHeight = useEmitterValue('totalListHeight')\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollTopCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent\n    )\n\n    useIsomorphicLayoutEffect(() => {\n      scrollerRef.current = window\n      return () => {\n        scrollerRef.current = null\n      }\n    }, [scrollerRef])\n\n    useEmitter('windowScrollTo', scrollToCallback)\n    useEmitter('scrollBy', scrollByCallback)\n    return createElement(\n      ScrollerComponent,\n      {\n        style: { position: 'relative', ...style, ...(totalListHeight !== 0 ? { height: totalListHeight } : {}) },\n        ...props,\n      },\n      children\n    )\n  })\n  return Scroller\n}\n\nconst Viewport: FC = ({ children }) => {\n  const viewportHeight = usePublisher('viewportHeight')\n  const viewportRef = useSize(compose(viewportHeight, prop('offsetHeight')))\n\n  return (\n    <div style={viewportStyle} ref={viewportRef}>\n      {children}\n    </div>\n  )\n}\n\nconst WindowViewport: FC = ({ children }) => {\n  const windowViewportRect = usePublisher('windowViewportRect')\n  const viewportRef = useWindowViewportRectRef(windowViewportRect)\n\n  return (\n    <div ref={viewportRef} style={viewportStyle}>\n      {children}\n    </div>\n  )\n}\n\nconst TopItemListContainer: FC = ({ children }) => {\n  const TopItemList = useEmitterValue('TopItemListComponent')\n  const headerHeight = useEmitterValue('headerHeight')\n  const style = { ...topItemListStyle, marginTop: `${headerHeight}px` }\n  return createElement(TopItemList || 'div', { style }, children)\n}\n\nconst ListRoot: FC<ListRootProps> = React.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue('useWindowScroll')\n  const showTopList = useEmitterValue('topItemsIndexes').length > 0\n  const TheScroller = useWindowScroll ? WindowScroller : Scroller\n  const TheViewport = useWindowScroll ? WindowViewport : Viewport\n  return (\n    <TheScroller {...props}>\n      <TheViewport>\n        <Header />\n        <Items />\n        <Footer />\n      </TheViewport>\n      {showTopList && (\n        <TopItemListContainer>\n          <Items showTopList={true} />\n        </TopItemListContainer>\n      )}\n    </TheScroller>\n  )\n})\n\nexport type ListHandle = RefHandle<typeof List>\n\nexport const { Component: List, usePublisher, useEmitterValue, useEmitter } = systemToComponent(\n  combinedSystem,\n  {\n    required: {},\n    optional: {\n      followOutput: 'followOutput',\n      firstItemIndex: 'firstItemIndex',\n      itemContent: 'itemContent',\n      groupContent: 'groupContent',\n      overscan: 'overscan',\n      totalCount: 'totalCount',\n      topItemCount: 'topItemCount',\n      initialTopMostItemIndex: 'initialTopMostItemIndex',\n      components: 'components',\n      groupCounts: 'groupCounts',\n      computeItemKey: 'computeItemKey',\n      defaultItemHeight: 'defaultItemHeight',\n      fixedItemHeight: 'fixedItemHeight',\n      scrollSeekConfiguration: 'scrollSeekConfiguration',\n      headerFooterTag: 'headerFooterTag',\n      data: 'data',\n      initialItemCount: 'initialItemCount',\n      initialScrollTop: 'initialScrollTop',\n      alignToBottom: 'alignToBottom',\n      useWindowScroll: 'useWindowScroll',\n      scrollerRef: 'scrollerRef',\n\n      // deprecated\n      item: 'item',\n      group: 'group',\n      topItems: 'topItems',\n      itemHeight: 'itemHeight',\n      scrollingStateChange: 'scrollingStateChange',\n      maxHeightCacheSize: 'maxHeightCacheSize',\n      footer: 'footer',\n      header: 'header',\n      ItemContainer: 'ItemContainer',\n      ScrollContainer: 'ScrollContainer',\n      ListContainer: 'ListContainer',\n      GroupContainer: 'GroupContainer',\n      emptyComponent: 'emptyComponent',\n      HeaderContainer: 'HeaderContainer',\n      FooterContainer: 'FooterContainer',\n      scrollSeek: 'scrollSeek',\n    },\n    methods: {\n      scrollToIndex: 'scrollToIndex',\n      scrollTo: 'scrollTo',\n      scrollBy: 'scrollBy',\n      adjustForPrependedItems: 'adjustForPrependedItems',\n    },\n    events: {\n      isScrolling: 'isScrolling',\n      endReached: 'endReached',\n      startReached: 'startReached',\n      rangeChanged: 'rangeChanged',\n      atBottomStateChange: 'atBottomStateChange',\n      atTopStateChange: 'atTopStateChange',\n      totalListHeightChanged: 'totalListHeightChanged',\n      itemsRendered: 'itemsRendered',\n      groupIndices: 'groupIndices',\n    },\n  },\n  ListRoot\n)\n\nconst Scroller = buildScroller({ usePublisher, useEmitterValue, useEmitter })\nconst WindowScroller = buildWindowScroller({ usePublisher, useEmitterValue, useEmitter })\n","import { SizeRange } from '../sizeSystem'\nimport useSize from './useSize'\n\nexport default function useChangedChildSizes(callback: (ranges: SizeRange[]) => void, enabled: boolean) {\n  return useSize((el: HTMLElement) => {\n    const ranges = getChangedChildSizes(el.children, 'offsetHeight')\n    if (ranges !== null) {\n      callback(ranges)\n    }\n  }, enabled)\n}\n\nfunction getChangedChildSizes(children: HTMLCollection, field: 'offsetHeight' | 'offsetWidth') {\n  const length = children.length\n\n  if (length === 0) {\n    return null\n  }\n\n  const results: SizeRange[] = []\n\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i) as HTMLElement\n\n    if (!child || child.dataset.index === undefined) {\n      continue\n    }\n\n    const index = parseInt(child.dataset.index!)\n    const knownSize = parseInt(child.dataset.knownSize!)\n    const size = child[field]\n\n    if (size === 0) {\n      throw new Error('Zero-sized element, this should not happen')\n    }\n\n    if (size === knownSize) {\n      continue\n    }\n\n    const lastResult = results[results.length - 1]\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({ startIndex: index, endIndex: index, size })\n    } else {\n      results[results.length - 1].endIndex++\n    }\n  }\n\n  return results\n}\n","import { RefHandle, systemToComponent } from '@virtuoso.dev/react-urx'\n\nimport * as u from '@virtuoso.dev/urx'\nimport * as React from 'react'\nimport { createElement, FC } from 'react'\nimport { gridSystem } from './gridSystem'\nimport useSize from './hooks/useSize'\nimport useWindowViewportRectRef from './hooks/useWindowViewportRect'\nimport { ComputeItemKey, GridComponents, GridItemContent, GridRootProps } from './interfaces'\nimport { addDeprecatedAlias, buildScroller, buildWindowScroller, identity, viewportStyle } from './List'\n\nconst gridComponentPropsSystem = u.system(() => {\n  const itemContent = u.statefulStream<GridItemContent>((index) => `Item ${index}`)\n  const components = u.statefulStream<GridComponents>({})\n  const itemClassName = u.statefulStream('virtuoso-grid-item')\n  const listClassName = u.statefulStream('virtuoso-grid-list')\n  const computeItemKey = u.statefulStream<ComputeItemKey>(identity)\n  const scrollerRef = u.statefulStream<(ref: HTMLElement | null) => void>(u.noop)\n\n  const distinctProp = <K extends keyof GridComponents>(propName: K, defaultValue: GridComponents[K] | null | 'div' = null) => {\n    return u.statefulStreamFromEmitter(\n      u.pipe(\n        components,\n        u.map((components) => components[propName]),\n        u.distinctUntilChanged()\n      ),\n      defaultValue\n    )\n  }\n\n  return {\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    scrollerRef,\n    ListComponent: distinctProp('List', 'div'),\n    ItemComponent: distinctProp('Item', 'div'),\n    ScrollerComponent: distinctProp('Scroller', 'div'),\n    ScrollSeekPlaceholder: distinctProp('ScrollSeekPlaceholder', 'div'),\n  }\n})\n\nconst combinedSystem = u.system(([gridSystem, gridComponentPropsSystem]) => {\n  const deprecatedProps = {\n    item: addDeprecatedAlias(gridComponentPropsSystem.itemContent, 'Rename the %citem%c prop to %citemContent.'),\n    ItemContainer: u.stream<any>(),\n    ScrollContainer: u.stream<any>(),\n    ListContainer: u.stream<any>(),\n    emptyComponent: u.stream<any>(),\n    scrollSeek: u.stream<any>(),\n  }\n\n  function deprecateComponentProp(stream: u.Stream<any>, componentName: string, propName: string) {\n    u.connect(\n      u.pipe(\n        stream,\n        u.withLatestFrom(gridComponentPropsSystem.components),\n        u.map(([comp, components]) => {\n          console.warn(`react-virtuoso: ${propName} property is deprecated. Pass components.${componentName} instead.`)\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          return { ...components, [componentName]: comp }\n        })\n      ),\n      gridComponentPropsSystem.components\n    )\n  }\n\n  u.subscribe(deprecatedProps.scrollSeek, ({ placeholder, ...config }) => {\n    console.warn(\n      `react-virtuoso: scrollSeek property is deprecated. Pass scrollSeekConfiguration and specify the placeholder in components.ScrollSeekPlaceholder instead.`\n    )\n    u.publish(gridComponentPropsSystem.components, {\n      ...u.getValue(gridComponentPropsSystem.components),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      ScrollSeekPlaceholder: placeholder,\n    })\n    u.publish(gridSystem.scrollSeekConfiguration, config)\n  })\n\n  deprecateComponentProp(deprecatedProps.ItemContainer, 'Item', 'ItemContainer')\n  deprecateComponentProp(deprecatedProps.ListContainer, 'List', 'ListContainer')\n  deprecateComponentProp(deprecatedProps.ScrollContainer, 'Scroller', 'ScrollContainer')\n\n  return { ...gridSystem, ...gridComponentPropsSystem, ...deprecatedProps }\n}, u.tup(gridSystem, gridComponentPropsSystem))\n\nconst GridItems: FC = React.memo(function GridItems() {\n  const gridState = useEmitterValue('gridState')\n  const listClassName = useEmitterValue('listClassName')\n  const itemClassName = useEmitterValue('itemClassName')\n  const itemContent = useEmitterValue('itemContent')\n  const computeItemKey = useEmitterValue('computeItemKey')\n  const isSeeking = useEmitterValue('isSeeking')\n  const ItemComponent = useEmitterValue('ItemComponent')!\n  const ListComponent = useEmitterValue('ListComponent')!\n  const ScrollSeekPlaceholder = useEmitterValue('ScrollSeekPlaceholder')!\n\n  const itemDimensions = usePublisher('itemDimensions')\n\n  const listRef = useSize((el) => {\n    const firstItem = el.firstChild as HTMLElement\n    if (firstItem) {\n      itemDimensions({\n        width: firstItem.offsetWidth,\n        height: firstItem.offsetHeight,\n      })\n    }\n  })\n\n  return createElement(\n    ListComponent,\n    { ref: listRef, className: listClassName, style: { paddingTop: gridState.offsetTop, paddingBottom: gridState.offsetBottom } },\n    gridState.items.map((item) => {\n      const key = computeItemKey(item.index)\n      return isSeeking\n        ? createElement(ScrollSeekPlaceholder, { key, style: { height: gridState.itemHeight, width: gridState.itemWidth } })\n        : createElement(ItemComponent, { className: itemClassName, 'data-index': item.index, key }, itemContent(item.index))\n    })\n  )\n})\n\nconst Viewport: FC = ({ children }) => {\n  const viewportDimensions = usePublisher('viewportDimensions')\n\n  const viewportRef = useSize((el) => {\n    viewportDimensions({\n      width: el.offsetWidth,\n      height: el.offsetHeight,\n    })\n  })\n\n  return (\n    <div style={viewportStyle} ref={viewportRef}>\n      {children}\n    </div>\n  )\n}\n\nconst WindowViewport: FC = ({ children }) => {\n  const windowViewportRect = usePublisher('windowViewportRect')\n  const viewportRef = useWindowViewportRectRef(windowViewportRect)\n\n  return (\n    <div ref={viewportRef} style={viewportStyle}>\n      {children}\n    </div>\n  )\n}\n\nconst GridRoot: FC<GridRootProps> = React.memo(function GridRoot({ ...props }) {\n  const useWindowScroll = useEmitterValue('useWindowScroll')\n  const TheScroller = useWindowScroll ? WindowScroller : Scroller\n  const TheViewport = useWindowScroll ? WindowViewport : Viewport\n\n  return (\n    <TheScroller {...props}>\n      <TheViewport>\n        <GridItems />\n      </TheViewport>\n    </TheScroller>\n  )\n})\n\nconst { Component: Grid, usePublisher, useEmitterValue, useEmitter } = systemToComponent(\n  combinedSystem,\n  {\n    optional: {\n      totalCount: 'totalCount',\n      overscan: 'overscan',\n      itemContent: 'itemContent',\n      components: 'components',\n      computeItemKey: 'computeItemKey',\n      initialItemCount: 'initialItemCount',\n      scrollSeekConfiguration: 'scrollSeekConfiguration',\n      listClassName: 'listClassName',\n      itemClassName: 'itemClassName',\n      useWindowScroll: 'useWindowScroll',\n      scrollerRef: 'scrollerRef',\n\n      // deprecated\n      item: 'item',\n      ItemContainer: 'ItemContainer',\n      ScrollContainer: 'ScrollContainer',\n      ListContainer: 'ListContainer',\n      scrollSeek: 'scrollSeek',\n    },\n    methods: {\n      scrollTo: 'scrollTo',\n      scrollBy: 'scrollBy',\n      scrollToIndex: 'scrollToIndex',\n    },\n    events: {\n      isScrolling: 'isScrolling',\n      endReached: 'endReached',\n      startReached: 'startReached',\n      rangeChanged: 'rangeChanged',\n      atBottomStateChange: 'atBottomStateChange',\n      atTopStateChange: 'atTopStateChange',\n    },\n  },\n  GridRoot\n)\n\nexport type foo<T> = T extends React.ForwardRefExoticComponent<React.RefAttributes<infer Handle>> ? Handle : never\n\nexport type GridHandle = RefHandle<typeof Grid>\nexport { Grid }\n\nconst Scroller = buildScroller({ usePublisher, useEmitterValue, useEmitter })\nconst WindowScroller = buildWindowScroller({ usePublisher, useEmitterValue, useEmitter })\n","import React, { ForwardRefExoticComponent, ReactElement, Ref } from 'react'\nimport { Grid, GridHandle } from './Grid'\n\nimport {\n  Components,\n  ComputeItemKey,\n  FollowOutput,\n  GroupContent,\n  GroupItemContent,\n  IndexLocationWithAlign,\n  ItemContent,\n  ListItem,\n  ListRange,\n  ScrollSeekConfiguration,\n} from './interfaces'\nimport { List, ListHandle } from './List'\ntype CompProps<T> = T extends React.ForwardRefExoticComponent<infer R> ? R : never\ntype ListProps = CompProps<typeof List>\ntype GridProps = CompProps<typeof Grid>\n\nexport interface VirtuosoProps<D> extends Omit<ListProps, 'groupCounts' | 'groupContent' | 'itemsRendered'> {\n  /**\n   * The total amount of items to be rendered.\n   */\n  totalCount?: number\n\n  /**\n   * The data items to be rendered. If data is set, the total count will be inferred from the length of the array.\n   */\n  data?: readonly D[]\n\n  /**\n   * Increases the visual window which is used to calculate the rendered items with the specified **amount in pixels**.\n   * Effectively, this makes the component \"chunk\" the rendering of new items by renderng more items than the necessary, but reducing the re-renders on scroll.\n   * Setting { main: number, reverse: number } lets you extend the list in both the main and the reverse scrollable directions.\n   */\n  overscan?: number | { main: number; reverse: number }\n\n  /**\n   * Set the amount of items to remain fixed at the top of the list.\n   *\n   * For a header that scrolls away when scrolling, check the `components.Header` property.\n   */\n  topItemCount?: number\n\n  /**\n   * Set to a value between 0 and totalCount - 1 to make the list start scrolled to that item.\n   */\n  initialTopMostItemIndex?: number\n\n  /**\n   * Set this value to offset the initial location of the list.\n   * Warning: using this property will still run a render cycle at the scrollTop: 0 list window.\n   * If possible, avoid using it and stick to `initialTopMostItemIndex` instead.\n   */\n  initialScrollTop?: number\n\n  /**\n   * Use for server-side rendering - if set, the list will render the specified amount of items\n   * regardless of the container / item size.\n   */\n  initialItemCount?: number\n\n  /**\n   * Use the `components` property for advanced customization of the elements rendered by the list.\n   */\n  components?: Components\n\n  /**\n   * Set the callback to specify the contents of the item.\n   */\n  itemContent?: ItemContent<D>\n\n  /**\n   * If specified, the component will use the function to generate the `key` property for each list item.\n   */\n  computeItemKey?: ComputeItemKey\n\n  /**\n   * By default, the component assumes the default item height from the first rendered item (rendering it as a \"probe\").\n   *\n   * If the first item turns out to be an outlier (very short or tall), the rest of the rendering will be slower,\n   * as multiple passes of rendering should happen for the list to fill the viewport.\n   *\n   * Setting `defaultItemHeight` causes the component to skip the \"probe\" rendering and use the property\n   * value as default height instead.\n   */\n  defaultItemHeight?: number\n\n  /**\n   * Can be used to improve performance if the rendered items are of known size.\n   * Setting it causes the component to skip item measurements.\n   */\n  fixedItemHeight?: number\n\n  /**\n   * Use to display placeholders if the user scrolls fast through the list.\n   *\n   * Set `components.ScrollSeekPlaceholder` to change the placeholder content.\n   */\n  scrollSeekConfiguration?: ScrollSeekConfiguration | false\n\n  /**\n   * If set to `true`, the list automatically scrolls to bottom if the total count is changed.\n   * Set to `\"smooth\"` for an animated scrolling.\n   *\n   * By default, `followOutput` scrolls down only if the list is already at the bottom.\n   * To implement an arbitrary logic behind that, pass a function:\n   *\n   * ```tsx\n   * <Virtuoso\n   *  followOutput={(isAtBottom: boolean) => {\n   *    if (expression) {\n   *      return 'smooth' // can be 'auto' or false to avoid scrolling\n   *    } else {\n   *      return false\n   *    }\n   *  }} />\n   * ```\n   */\n  followOutput?: FollowOutput\n\n  /**\n   * Set to customize the wrapper tag for the header and footer components (default is `div`).\n   */\n  headerFooterTag?: string\n\n  /**\n   * Use when implementing inverse infinite scrolling - decrease the value this property\n   * in combination with  `data` or `totalCount` to prepend items to the top of the list.\n   *\n   * Warning: the firstItemIndex should **be a positive number**, based on the total amount of items to be displayed.\n   */\n  firstItemIndex?: number\n\n  /**\n   * Called when the list starts/stops scrolling.\n   */\n  isScrolling?: (isScrolling: boolean) => void\n\n  /**\n   * Gets called when the user scrolls to the end of the list.\n   * Receives the last item index as an argument. Can be used to implement endless scrolling.\n   */\n  endReached?: (index: number) => void\n\n  /**\n   * Called when the user scrolls to the start of the list.\n   */\n  startReached?: (index: number) => void\n\n  /**\n   * Called with the new set of items each time the list items are rendered due to scrolling.\n   */\n  rangeChanged?: (range: ListRange) => void\n\n  /**\n   * Called with true / false when the list has reached the bottom / gets scrolled up.\n   * Can be used to load newer items, like `tail -f`.\n   */\n  atBottomStateChange?: (atBottom: boolean) => void\n\n  /**\n   * Called with `true` / `false` when the list has reached the top / gets scrolled down.\n   */\n  atTopStateChange?: (atTop: boolean) => void\n\n  /**\n   * Called when the total list height is changed due to new items or viewport resize.\n   */\n  totalListHeightChanged?: (height: number) => void\n\n  /**\n   * Called with the new set of items each time the list items are rendered due to scrolling.\n   */\n  itemsRendered?: (items: ListItem<D>[]) => void\n\n  /**\n   * Setting `alignToBottom` to `true` aligns the items to the bottom of the list if the list is shorter than the viewport.\n   * Use `followOutput` property to keep the list aligned when new items are appended.\n   */\n  alignToBottom?: boolean\n\n  /**\n   * Uses the document scroller rather than wrapping the list in its own.\n   */\n  useWindowScroll?: boolean\n\n  /**\n   * Provides access to the root DOM element\n   */\n  scrollerRef?: (ref: HTMLElement | Window | null) => any\n}\n\nexport interface GroupedVirtuosoProps<D>\n  extends Omit<VirtuosoProps<D>, 'totalCount' | 'itemContent'>,\n    Pick<ListProps, 'groupCounts' | 'groupContent'> {\n  /**\n   * Specifies the amount of items in each group (and, actually, how many groups are there).\n   * For example, passing [20, 30] will display 2 groups with 20 and 30 items each.\n   */\n  groupCounts?: number[]\n\n  /**\n   * Specifies how each each group header gets rendered. The callback receives the zero-based index of the group.\n   */\n  groupContent?: GroupContent\n\n  /**\n   * Specifies how each each item gets rendered.\n   */\n  itemContent?: GroupItemContent<D>\n}\n\nexport interface VirtuosoGridProps extends GridProps {\n  /**\n   * The total amount of items to be rendered.\n   */\n  totalCount: GridProps['totalCount']\n\n  /**\n   * Set the callback to specify the contents of the item.\n   */\n  itemContent?: GridProps['itemContent']\n\n  /**\n   * Use the `components` property for advanced customization of the elements rendered by the list.\n   */\n  components?: GridProps['components']\n\n  /**\n   * Set the overscan property to make the component \"chunk\" the rendering of new items on scroll.\n   * The property causes the component to render more items than the necessary, but reduces the re-renders on scroll.\n   * Setting { main: number, reverse: number } lets you extend the list in both the main and the reverse scrollable directions.\n   */\n  overscan?: number | { main: number; reverse: number }\n\n  /**\n   * If specified, the component will use the function to generate the `key` property for each list item.\n   */\n  computeItemKey?: ComputeItemKey\n\n  /**\n   * Use to display placeholders if the user scrolls fast through the list.\n   *\n   * Set `components.ScrollSeekPlaceholder` to change the placeholder content.\n   */\n  scrollSeekConfiguration?: ScrollSeekConfiguration | false\n\n  /**\n   * Called when the list starts/stops scrolling.\n   */\n  isScrolling?: (isScrolling: boolean) => void\n\n  /**\n   * Gets called when the user scrolls to the end of the list.\n   * Receives the last item index as an argument. Can be used to implement endless scrolling.\n   */\n  endReached?: (index: number) => void\n\n  /**\n   * Called when the user scrolls to the start of the list.\n   */\n  startReached?: (index: number) => void\n\n  /**\n   * Called with the new set of items each time the list items are rendered due to scrolling.\n   */\n  rangeChanged?: (range: ListRange) => void\n\n  /**\n   * Called with true / false when the list has reached the bottom / gets scrolled up.\n   * Can be used to load newer items, like `tail -f`.\n   */\n  atBottomStateChange?: (atBottom: boolean) => void\n\n  /**\n   * Called with `true` / `false` when the list has reached the top / gets scrolled down.\n   */\n  atTopStateChange?: (atTop: boolean) => void\n\n  /**\n   * Provides access to the root DOM element\n   */\n  scrollerRef?: (ref: HTMLElement | null) => any\n\n  /**\n   * Sets the className for the list DOM element\n   */\n  listClassName?: string\n\n  /**\n   * Sets the grid items' className\n   */\n  itemClassName?: string\n\n  /**\n   * Uses the document scroller rather than wrapping the grid in its own.\n   */\n  useWindowScroll?: boolean\n}\n\nexport interface VirtuosoHandle extends ListHandle {\n  /**\n   * Scrolls the component to the specified item index. See {{IndexLocationWithAlign}} for more options.\n   */\n  scrollToIndex(location: number | IndexLocationWithAlign): void\n  /**\n   * Scrolls the component to the specified location. See [ScrollToOptions (MDN)](https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions)\n   */\n  scrollTo(location: ScrollToOptions): void\n  /**\n   * Scrolls the component with the specified amount. See [ScrollToOptions (MDN)](https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions)\n   */\n  scrollBy(location: ScrollToOptions): void\n}\n\nexport interface GroupedVirtuosoHandle extends ListHandle {\n  scrollToIndex(location: number | IndexLocationWithAlign): void\n  scrollTo(location: ScrollToOptions): void\n  scrollBy(location: ScrollToOptions): void\n}\n\nexport interface VirtuosoGridHandle extends GridHandle {\n  scrollToIndex(location: number | IndexLocationWithAlign): void\n  scrollTo(location: ScrollToOptions): void\n  scrollBy(location: ScrollToOptions): void\n}\n\nexport const Virtuoso = List as <D extends unknown = any>(props: VirtuosoProps<D> & { ref?: Ref<VirtuosoHandle> }) => ReactElement\nexport const GroupedVirtuoso = List as <D extends unknown = any>(\n  props: GroupedVirtuosoProps<D> & { ref?: Ref<GroupedVirtuosoHandle> }\n) => ReactElement\nexport const VirtuosoGrid: ForwardRefExoticComponent<VirtuosoGridProps> = Grid\n","import objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nexport default index;\n","import * as React from 'react';\nimport createSvgIcon from './utils/createSvgIcon';\nexport default createSvgIcon( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z\"\n}), 'Delete');","import * as React from 'react';\nimport createSvgIcon from './utils/createSvgIcon';\nexport default createSvgIcon( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z\"\n}), 'ArrowUpward');","import * as React from 'react';\nimport createSvgIcon from './utils/createSvgIcon';\nexport default createSvgIcon( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z\"\n}), 'ArrowDownward');"],"sourceRoot":""}